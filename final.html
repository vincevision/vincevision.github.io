<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BOS Signals â€” Deriv API (App ID 1089)</title>
  <style>
    :root {
      --bg: #0b0e11;
      --panel: #12161c;
      --panel-2: #171b22;
      --text: #e6e8ea;
      --muted: #9aa4af;
      --green: #22c55e;
      --red: #ef4444;
      --yellow: #f59e0b;
      --blue: #3b82f6;
      --accent: #8b5cf6;
      --card: #0f1318;
      --border: #232a34;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    a { color: var(--blue); text-decoration: none; }
    .app { max-width: 1200px; margin: 0 auto; padding: 24px; }
    header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
    .title { font-weight: 700; font-size: 22px; display: flex; align-items: center; gap: 8px; }
    .subtitle { color: var(--muted); font-size: 13px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; }
    .col { flex: 1 1 280px; min-width: 280px; }
    .panel {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid var(--border);
      border-radius: 12px; padding: 16px;
    }
    .panel h3 { margin: 0 0 8px 0; font-size: 16px; }
    .panel h4 { margin: 12px 0 6px; font-size: 14px; color: var(--muted); }
    .controls { display: grid; grid-template-columns: repeat(3,minmax(160px, 1fr)); gap: 12px; }
    .controls .field { display: flex; flex-direction: column; gap: 6px; }
    label { font-size: 12px; color: var(--muted); }
    input, select, button {
      background: var(--card); color: var(--text); border: 1px solid var(--border);
      border-radius: 8px; padding: 10px 12px; font-size: 14px; outline: none;
    }
    button { cursor: pointer; transition: .15s ease; }
    button.primary { background: linear-gradient(180deg, #1e293b, #0f172a); border-color: #334155; }
    button.primary:hover { filter: brightness(1.1); }
    button.danger { background: linear-gradient(180deg, #3f1d20, #2a0f11); border-color: #5b2429; }
    .status-dot { width: 10px; height: 10px; border-radius: 999px; display: inline-block; margin-right: 8px; }
    .ok { background: var(--green); }
    .warn { background: var(--yellow); }
    .err { background: var(--red); }
    .muted { color: var(--muted); }
    .badge {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 10px; border-radius: 999px; font-size: 12px; border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
    }
    .badge.green { border-color: #1f4d33; background: rgba(34,197,94,0.08); color: #98f7bf; }
    .badge.red { border-color: #4d1f1f; background: rgba(239,68,68,0.08); color: #ffb3b3; }
    .badge.blue { border-color: #1f2c4d; background: rgba(59,130,246,0.08); color: #aac7ff; }
    .badge.yellow { border-color: #4d421f; background: rgba(245,158,11,0.1); color: #f8e1a1; }
    .grid-2 { display: grid; grid-template-columns: repeat(2, minmax(240px,1fr)); gap: 12px; }
    .grid-3 { display: grid; grid-template-columns: repeat(3, minmax(220px,1fr)); gap: 12px; }
    .kpi {
      background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 12px;
      display: grid; gap: 6px;
    }
    .kpi .label { font-size: 12px; color: var(--muted); }
    .kpi .value { font-size: 15px; font-weight: 600; }
    .divider { height: 1px; background: var(--border); margin: 10px 0; }
    .log {
      height: 160px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: #0a0d11; border-radius: 8px; border: 1px solid var(--border); padding: 10px; font-size: 12px;
      color: #c9d1d9;
    }
    .footer { margin-top: 18px; color: var(--muted); font-size: 12px; }
    .hint { color: var(--muted); font-size: 12px; margin-top: 8px; }
    .flex { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .right { margin-left: auto; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .danger-text { color: #ff9e9e; }

    /* Table */
    .table-wrap { overflow: auto; border: 1px solid var(--border); border-radius: 10px; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    thead { background: #0f141a; }
    th, td { padding: 10px; border-bottom: 1px solid var(--border); white-space: nowrap; }
    tbody tr:hover { background: rgba(255,255,255,0.03); }
    .link { color: #8ab4ff; cursor: pointer; }
    .pill {
      padding: 4px 8px; border-radius: 999px; border: 1px solid var(--border);
      background: rgba(255,255,255,0.04); font-size: 12px;
    }
    .pill.green { border-color: #1f4d33; background: rgba(34,197,94,0.08); color: #98f7bf; }
    .pill.red   { border-color: #4d1f1f; background: rgba(239,68,68,0.08); color: #ffb3b3; }
    .pill.yellow{ border-color: #4d421f; background: rgba(245,158,11,0.1); color: #f8e1a1; }
    .nowrap { white-space: nowrap; }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="title">
      ðŸ”” BOS Signals
      <span class="subtitle">Bollinger + StochRSI confluence with Lower-TF BoS (Deriv API)</span>
    </div>
    <div>
      <span class="badge blue">App ID: 1089</span>
      <span id="conn-badge" class="badge yellow"><span class="status-dot warn"></span>Connecting...</span>
    </div>
  </header>

  <div class="panel">
    <h3>Signal Settings</h3>
    <div class="controls" style="margin-top: 10px;">
      <div class="field">
        <label>Market</label>
        <select id="marketFilter"></select>
      </div>
      <div class="field">
        <label>Symbol</label>
        <select id="symbol"></select>
      </div>
      <div class="field">
        <label>Higher Timeframe</label>
        <select id="htf">
          <option value="900">15m</option>
          <option value="1800">30m</option>
          <option value="3600" selected>1h</option>
          <option value="14400">4h</option>
          <option value="86400">1d</option>
        </select>
      </div>
      <div class="field">
        <label>Lower Timeframe</label>
        <select id="ltf">
          <option value="60" selected>1m</option>
          <option value="180">3m</option>
          <option value="300">5m</option>
          <option value="900">15m</option>
        </select>
      </div>

      <div class="field">
        <label>Bollinger Period</label>
        <input id="bbPeriod" type="number" min="5" max="200" value="20"/>
      </div>
      <div class="field">
        <label>Bollinger StdDev</label>
        <input id="bbMult" type="number" step="0.1" min="0.1" max="6" value="2"/>
      </div>
      <div class="field">
        <label>RSI Length</label>
        <input id="rsiLen" type="number" min="2" max="100" value="14"/>
      </div>
      <div class="field">
        <label>StochRSI Length</label>
        <input id="stochLen" type="number" min="2" max="100" value="14"/>
      </div>
      <div class="field">
        <label>Smooth K</label>
        <input id="kLen" type="number" min="1" max="20" value="3"/>
      </div>
      <div class="field">
        <label>Smooth D</label>
        <input id="dLen" type="number" min="1" max="20" value="3"/>
      </div>
      <div class="field">
        <label>Overbought / Oversold</label>
        <div class="row">
          <input id="obLevel" type="number" min="50" max="100" value="80" style="width: 48%;"/>
          <input id="osLevel" type="number" min="0" max="50" value="20" style="width: 48%;"/>
        </div>
      </div>
      <div class="field">
        <label>Fractal Left/Right (LTF)</label>
        <div class="row">
          <input id="fractL" type="number" min="1" max="5" value="2" style="width: 48%;"/>
          <input id="fractR" type="number" min="1" max="5" value="2" style="width: 48%;"/>
        </div>
      </div>
      <div class="field">
        <label>History Size (candles)</label>
        <input id="histCount" type="number" min="200" max="1500" value="500"/>
      </div>
    </div>

    <div class="row" style="margin-top: 12px;">
      <div class="flex">
        <button id="startBtn" class="primary">Start / Update</button>
        <button id="stopBtn" class="danger">Stop</button>
        <span class="hint">Pick a symbol and press Start to stream live.</span>
      </div>
      <div class="right flex">
        <span class="badge">HTF Confluence: <strong id="confluence-badge">Pending</strong></span>
        <span class="badge">LTF BoS: <strong id="bos-badge">Waiting</strong></span>
      </div>
    </div>
  </div>

  <div class="panel">
    <h3>Autoscan</h3>
    <div class="controls">
      <div class="field">
        <label>Universe</label>
        <div><span id="universeCount" class="badge">Filtered symbols: 0</span></div>
        <div class="hint">Auto-scans the currently filtered market.</div>
      </div>
      <div class="field">
        <label>Scan Interval (seconds)</label>
        <input id="scanInterval" type="number" min="10" value="60"/>
      </div>
      <div class="field">
        <label>Max Symbols per Run</label>
        <input id="scanMax" type="number" min="5" max="200" value="50"/>
      </div>
    </div>
    <div class="row" style="margin-top: 12px;">
      <div class="flex">
        <button id="scanStartBtn" class="primary">Start Autoscan</button>
        <button id="scanStopBtn" class="danger">Stop Autoscan</button>
        <span id="scanStatus" class="badge yellow"><span class="status-dot warn"></span>Idle</span>
      </div>
      <div class="right grid-3" style="min-width: 420px;">
        <div class="kpi">
          <div class="label">Last Scan</div>
          <div class="value" id="scanLast">â€”</div>
        </div>
        <div class="kpi">
          <div class="label">Symbols Scanned</div>
          <div class="value" id="scanCount">0</div>
        </div>
        <div class="kpi">
          <div class="label">Signals Found</div>
          <div class="value" id="scanFound">0</div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel">
    <h3>Scan Results</h3>
    <div class="table-wrap">
      <table>
        <thead>
          <tr>
            <th>Symbol</th>
            <th>Bias</th>
            <th>HTF Time</th>
            <th>Safety TP (BB mid)</th>
            <th>BoS</th>
            <th>Break Level</th>
            <th>Updated</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="scanTableBody"></tbody>
      </table>
    </div>
    <div class="hint">Click Go Live to stream that symbol on the signal panels below.</div>
  </div>

  <div class="row" style="margin-top: 12px;">
    <div class="col">
      <div class="panel">
        <h3>Higher Timeframe Signal</h3>
        <div class="grid-3">
          <div class="kpi">
            <div class="label">Bias</div>
            <div class="value" id="bias">Neutral</div>
            <div class="hint">Long if oversold + K crosses up D; Short if overbought + K crosses down D</div>
          </div>
          <div class="kpi">
            <div class="label">Bollinger Bands (last)</div>
            <div class="value" id="bbVals">â€”</div>
            <div class="hint">Lower / Mid / Upper</div>
          </div>
          <div class="kpi">
            <div class="label">Stoch RSI (last)</div>
            <div class="value" id="stochVals">â€”</div>
            <div class="hint">%K / %D</div>
          </div>
        </div>

        <div class="divider"></div>
        <div class="grid-2">
          <div class="kpi">
            <div class="label">Confluence Status</div>
            <div class="value" id="confluenceStatus"><span class="badge yellow">Waiting for confluence</span></div>
          </div>
          <div class="kpi">
            <div class="label">Safety TP (BB mid)</div>
            <div class="value" id="tpMid">â€”</div>
            <div class="hint">Midline from HTF at time of confluence</div>
          </div>
        </div>
        <div id="htfNote" class="hint" style="margin-top:8px;">â€”</div>
      </div>
    </div>

    <div class="col">
      <div class="panel">
        <h3>Lower Timeframe Structure</h3>
        <div class="grid-2">
          <div class="kpi">
            <div class="label">Reference Swing Level</div>
            <div class="value" id="swingRef">â€”</div>
            <div class="hint">Last confirmed fractal on LTF before the HTF signal</div>
          </div>
          <div class="kpi">
            <div class="label">BoS Status</div>
            <div class="value" id="bosStatus"><span class="badge">Waiting for HTF confluence</span></div>
            <div class="hint">We wait for close beyond that swing level</div>
          </div>
        </div>
        <div class="divider"></div>
        <div class="grid-3">
          <div class="kpi">
            <div class="label">Break Level</div>
            <div class="value" id="breakLevel">â€”</div>
          </div>
          <div class="kpi">
            <div class="label">Break Time</div>
            <div class="value" id="breakTime">â€”</div>
          </div>
          <div class="kpi">
            <div class="label">Current Price (LTF)</div>
            <div class="value" id="currPrice">â€”</div>
          </div>
        </div>

        <!-- New: Suggested SL + R:R -->
        <div class="divider"></div>
        <div class="grid-3">
          <div class="kpi">
            <div class="label">Suggested SL</div>
            <div class="value" id="sugSL">â€”</div>
            <div class="hint">Structure Â± ATR buffer</div>
          </div>
          <div class="kpi">
            <div class="label">Entry (Break Close)</div>
            <div class="value" id="entryPrice">â€”</div>
          </div>
          <div class="kpi">
            <div class="label">R:R to Mid TP</div>
            <div class="value" id="rrVal">â€”</div>
          </div>
        </div>
        <div id="slNote" class="hint" style="margin-top:8px;">â€”</div>

        <div id="ltfNote" class="hint" style="margin-top:8px;">â€”</div>
      </div>
    </div>
  </div>

  <div class="panel" style="margin-top: 12px;">
    <h3>Live Log</h3>
    <div id="log" class="log"></div>
    <div class="footer">For education only. Trading involves risk. This tool does not provide financial advice.</div>
  </div>
</div>

<script>
/** Deriv WebSocket API setup */
const APP_ID = 1089;
const WS_URL = `wss://ws.derivws.com/websockets/v3?app_id=${APP_ID}`;

let ws = null;
let isOpen = false;
let subs = {}; // id -> {symbol, granularity, role}
let htfCandles = [];
let ltfCandles = [];
let htfParams = null;
let ltfParams = null;

let confluence = null; // { type: 'long'|'short', idx, time, tpMid, bbMid, bbUpper, bbLower }
let bosState = null;   // { broken: bool, level, time, type }

let REQUEST_ID = 1;
const pending = {}; // req_id -> {res, rej}

const el = id => document.getElementById(id);
const logEl = el('log');

/** Symbols & Autoscan state */
let symbolsAll = [];        // [{symbol, display_name, market, submarket, is_trading}]
let filteredSymbols = [];   // by market filter
let scanTimer = null;
let scanRunning = false;
let scanStats = { last: null, count: 0, found: 0 };
let scanResults = {}; // symbol -> { symbol, display, bias, time, tpMid, bos, breakLevel, breakTime, updated }

/** Logging */
function log(...args) {
  const s = args.map(x => typeof x === 'object' ? JSON.stringify(x) : String(x)).join(' ');
  const time = new Date().toLocaleTimeString();
  logEl.textContent += `[${time}] ${s}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

function setConn(status) {
  const badge = el('conn-badge');
  if (status === 'open') {
    badge.innerHTML = '<span class="status-dot ok"></span>Connected';
    badge.className = 'badge';
  } else if (status === 'connecting') {
    badge.innerHTML = '<span class="status-dot warn"></span>Connecting...';
    badge.className = 'badge yellow';
  } else {
    badge.innerHTML = '<span class="status-dot err"></span>Disconnected';
    badge.className = 'badge red';
  }
}

/** Utils */
function toNum(x){ return typeof x === 'string' ? parseFloat(x) : x; }
function fmt(n) {
  if (n == null || !isFinite(n)) return 'â€”';
  const abs = Math.abs(n);
  const fixed = abs >= 100 ? 2 : abs >= 10 ? 3 : 5;
  let s = n.toFixed(fixed);
  s = s.replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'');
  return s;
}
function epochToStr(e) { try { return new Date(e * 1000).toLocaleString(); } catch { return 'â€”'; } }
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

/** Indicators */
function SMA(values, period) {
  const out = new Array(values.length).fill(null);
  let sum = 0;
  for (let i = 0; i < values.length; i++) {
    const v = values[i];
    if (v == null) { out[i] = null; continue; }
    sum += v;
    if (i >= period) sum -= values[i - period];
    if (i >= period - 1) out[i] = sum / period;
  }
  return out;
}
function rollingStd(values, period) {
  const out = new Array(values.length).fill(null);
  for (let i = 0; i < values.length; i++) {
    if (i >= period - 1) {
      const start = i - period + 1;
      const slice = values.slice(start, i + 1);
      let sum = 0; let n = 0;
      for (const v of slice) { if (v != null) { sum += v; n++; } }
      if (n === period) {
        const mean = sum / period;
        let variance = 0;
        for (const v of slice) variance += Math.pow(v - mean, 2);
        out[i] = Math.sqrt(variance / period);
      }
    }
  }
  return out;
}
function bollinger(closes, period, mult) {
  const ma = SMA(closes, period);
  const sd = rollingStd(closes, period);
  const upper = ma.map((m, i) => m != null && sd[i] != null ? m + mult * sd[i] : null);
  const lower = ma.map((m, i) => m != null && sd[i] != null ? m - mult * sd[i] : null);
  return { ma, upper, lower };
}
function RSI(closes, period) {
  const out = new Array(closes.length).fill(null);
  if (closes.length < period + 1) return out;
  let gains = 0, losses = 0;
  for (let i = 1; i <= period; i++) {
    const delta = closes[i] - closes[i - 1];
    if (delta >= 0) gains += delta; else losses += -delta;
  }
  let avgGain = gains / period;
  let avgLoss = losses / period;
  out[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
  for (let i = period + 1; i < closes.length; i++) {
    const delta = closes[i] - closes[i - 1];
    const gain = Math.max(delta, 0);
    const loss = Math.max(-delta, 0);
    avgGain = (avgGain * (period - 1) + gain) / period;
    avgLoss = (avgLoss * (period - 1) + loss) / period;
    const rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
    out[i] = 100 - 100 / (1 + rs);
  }
  return out;
}
function SMA_smooth(arr, period) {
  const out = new Array(arr.length).fill(null);
  for (let i = 0; i < arr.length; i++) {
    let count = 0, sum = 0, j = i;
    while (j >= 0 && count < period) {
      const v = arr[j];
      if (v != null && isFinite(v)) { sum += v; count++; }
      j--;
    }
    if (count === period) out[i] = sum / period;
  }
  return out;
}
function stochRSI(closes, rsiLen = 14, stochLen = 14, kLen = 3, dLen = 3) {
  const rsi = RSI(closes, rsiLen);
  const stoch = new Array(closes.length).fill(null);
  for (let i = 0; i < closes.length; i++) {
    if (i >= rsiLen + stochLen - 1) {
      const start = i - stochLen + 1;
      const slice = rsi.slice(start, i + 1).filter(x => x != null);
      if (slice.length === stochLen) {
        const min = Math.min(...slice);
        const max = Math.max(...slice);
        stoch[i] = (max - min) === 0 ? 0 : ((rsi[i] - min) / (max - min)) * 100;
      }
    }
  }
  const k = SMA_smooth(stoch, kLen);
  const d = SMA_smooth(k, dLen);
  return { rsi, stoch, k, d };
}
function crossedAbove(a, b, i) {
  return i > 0 && a[i - 1] != null && b[i - 1] != null && a[i] != null && b[i] != null && a[i - 1] < b[i - 1] && a[i] >= b[i];
}
function crossedBelow(a, b, i) {
  return i > 0 && a[i - 1] != null && b[i - 1] != null && a[i] != null && b[i] != null && a[i - 1] > b[i - 1] && a[i] <= b[i];
}

/** ATR for SL buffer */
function ATR(candles, period = 14) {
  const n = candles.length;
  if (n < period) return new Array(n).fill(null);
  const tr = new Array(n).fill(null);
  for (let i = 0; i < n; i++) {
    const h = toNum(candles[i].high), l = toNum(candles[i].low);
    const pc = i > 0 ? toNum(candles[i - 1].close) : null;
    const r1 = h - l;
    const r2 = pc != null ? Math.abs(h - pc) : r1;
    const r3 = pc != null ? Math.abs(l - pc) : r1;
    tr[i] = Math.max(r1, r2, r3);
  }
  const atr = new Array(n).fill(null);
  let sum = 0;
  for (let i = 0; i < period; i++) sum += tr[i];
  atr[period - 1] = sum / period;
  for (let i = period; i < n; i++) {
    atr[i] = (atr[i - 1] * (period - 1) + tr[i]) / period; // Wilder's
  }
  return atr;
}

/** Swings / Fractals */
function findFractals(candles, left = 2, right = 2) {
  const highs = [], lows = [];
  for (let i = left; i < candles.length - right; i++) {
    let isHigh = true, isLow = true;
    const hi = toNum(candles[i].high);
    const lo = toNum(candles[i].low);
    for (let k = 1; k <= left; k++) {
      if (!(hi > toNum(candles[i - k].high))) isHigh = false;
      if (!(lo < toNum(candles[i - k].low))) isLow = false;
    }
    for (let k = 1; k <= right; k++) {
      if (!(hi > toNum(candles[i + k].high))) isHigh = false;
      if (!(lo < toNum(candles[i + k].low))) isLow = false;
    }
    if (isHigh) highs.push({ idx: i, price: hi, time: candles[i].open_time });
    if (isLow) lows.push({ idx: i, price: lo, time: candles[i].open_time });
  }
  return { highs, lows };
}

/** HTF Confluence detection */
function detectHTFConfluence(candles, params) {
  const closes = candles.map(c => toNum(c.close));
  const bb = bollinger(closes, params.bbPeriod, params.bbMult);
  const st = stochRSI(closes, params.rsiLen, params.stochLen, params.kLen, params.dLen);
  const iLast = closes.length - 1;
  const lookback = 3;
  let found = null;

  for (let i = iLast; i >= Math.max(0, iLast - lookback); i--) {
    const price = closes[i];
    const lower = bb.lower[i], upper = bb.upper[i];
    const k = st.k[i], d = st.d[i];
    if ([price, lower, upper, k, d].some(x => x == null || !isFinite(x))) continue;

    const osConfl = price <= lower && crossedAbove(st.k, st.d, i) && Math.min(k, d) <= params.osLevel;
    const obConfl = price >= upper && crossedBelow(st.k, st.d, i) && Math.max(k, d) >= params.obLevel;

    if (osConfl || obConfl) {
      found = {
        type: osConfl ? 'long' : 'short',
        idx: i,
        time: candles[i].open_time,
        bbLower: bb.lower[i],
        bbUpper: bb.upper[i],
        bbMid: bb.ma[i],
        k: st.k[i],
        d: st.d[i],
        price: price
      };
      break;
    }
  }
  return { bb, st, found };
}

/** LTF BoS after confluence */
function detectLTFBoS(candles, ltfParams, confluence) {
  if (!confluence) return { state: null };
  const { type, time: htfTime } = confluence;
  if (!candles.length) return { state: null };

  const { highs, lows } = findFractals(candles, ltfParams.fractL, ltfParams.fractR);
  let ref = null;
  if (type === 'long') {
    const candidates = highs.filter(h => h.time <= htfTime);
    ref = candidates.length ? candidates[candidates.length - 1] : null;
  } else {
    const candidates = lows.filter(l => l.time <= htfTime);
    ref = candidates.length ? candidates[candidates.length - 1] : null;
  }
  if (!ref) return { state: { exists: false, note: 'No confirmed reference swing before HTF event' } };

  const startIdx = candles.findIndex(c => c.open_time >= htfTime);
  let broken = false, breakCandle = null, level = ref.price;
  for (let i = Math.max(0, startIdx); i < candles.length; i++) {
    const c = candles[i];
    if (type === 'long') {
      if (toNum(c.close) > level) { broken = true; breakCandle = c; break; }
    } else {
      if (toNum(c.close) < level) { broken = true; breakCandle = c; break; }
    }
  }
  return {
    state: {
      exists: true,
      type,
      ref,
      broken,
      level,
      breakCandle,
    }
  };
}

/** Deriv WebSocket handling */
function ensureWS() {
  if (ws && isOpen) return;
  if (ws) { try { ws.close(); } catch {} }
  setConn('connecting');
  ws = new WebSocket(WS_URL);
  ws.onopen = () => {
    isOpen = true;
    setConn('open');
    log('WebSocket connected.');
    fetchActiveSymbols().then(() => {
      log('Active symbols loaded:', filteredSymbols.length);
    }).catch(e => log('Active symbols error', e?.message || e));
  };
  ws.onclose = () => {
    isOpen = false;
    setConn('closed');
    log('WebSocket closed.');
  };
  ws.onerror = (e) => {
    log('WebSocket error', e?.message || e);
  };
  ws.onmessage = onMessage;
}

function waitForOpen() {
  return new Promise(resolve => {
    if (isOpen) return resolve();
    const iv = setInterval(() => {
      if (isOpen) { clearInterval(iv); resolve(); }
    }, 50);
  });
}

function sendRequest(req) {
  ensureWS();
  return waitForOpen().then(() => {
    const id = REQUEST_ID++;
    req.req_id = id;
    return new Promise((res, rej) => {
      pending[id] = { res, rej };
      try { ws.send(JSON.stringify(req)); }
      catch (e) { delete pending[id]; rej(e); }
    });
  });
}

function subscribeCandles(symbol, granularity, count, role) {
  ensureWS();
  const req = {
    ticks_history: symbol,
    end: 'latest',          // last N candles up to now
    count,
    granularity,
    style: 'candles',
    subscribe: 1
  };
  try {
    ws.send(JSON.stringify(req));
    log(`Subscribing ${role}: ${symbol} @ ${granularity}s (count=${count})`);
  } catch (e) {
    log('Subscribe error', e?.message || e);
  }
}

function forget(id) {
  if (!id || !isOpen) return;
  ws.send(JSON.stringify({ forget: id }));
  log('Unsubscribed', id);
}

function clearSubs() {
  const ids = Object.keys(subs);
  for (const id of ids) forget(id);
  subs = {};
}

function onMessage(ev) {
  let data;
  try { data = JSON.parse(ev.data); } catch { return; }

  // Resolve pending one-shot requests first
  if (data.req_id && pending[data.req_id]) {
    const { res } = pending[data.req_id];
    delete pending[data.req_id];
    res(data);
    return;
  }

  if (data.error) {
    log('Error:', data.error.message || JSON.stringify(data.error));
    return;
  }
  const msg = data.msg_type;

  if (msg === 'candles') {
    const { candles, subscription, echo_req } = data;
    if (subscription && subscription.id) {
      const role = deduceRole(echo_req?.granularity, echo_req?.ticks_history);
      subs[subscription.id] = { symbol: echo_req.ticks_history, granularity: echo_req.granularity, role };
    }
    if (echo_req?.granularity === Number(htfParams?.granularity) && echo_req?.ticks_history === htfParams?.symbol) {
      htfCandles = normalizeCandles(candles);
      evaluate();
    } else if (echo_req?.granularity === Number(ltfParams?.granularity) && echo_req?.ticks_history === ltfParams?.symbol) {
      ltfCandles = normalizeCandles(candles);
      evaluate();
    }
  } else if (msg === 'ohlc') {
    const { ohlc, subscription } = data;
    const id = subscription?.id;
    if (!id || !subs[id]) return;
    const role = subs[id].role;
    if (role === 'HTF') {
      htfCandles = upsertOhlc(htfCandles, ohlc);
      evaluate();
    } else if (role === 'LTF') {
      ltfCandles = upsertOhlc(ltfCandles, ohlc);
      evaluate();
    }
  } else if (msg === 'ping') {
    // heartbeat ok
  }
}

function deduceRole(gran, symbol) {
  const g = Number(gran);
  if (htfParams && Number(htfParams.granularity) === g && htfParams.symbol === symbol) return 'HTF';
  if (ltfParams && Number(ltfParams.granularity) === g && ltfParams.symbol === symbol) return 'LTF';
  return 'UNK';
}

function normalizeCandles(candles) {
  return candles.map(c => ({
    open_time: c.epoch ?? c.open_time,
    open: toNum(c.open),
    high: toNum(c.high),
    low: toNum(c.low),
    close: toNum(c.close)
  })).sort((a,b) => a.open_time - b.open_time);
}

function upsertOhlc(arr, o) {
  const epoch = o.epoch ?? o.open_time;
  const rec = {
    open_time: epoch,
    open: toNum(o.open),
    high: toNum(o.high),
    low: toNum(o.low),
    close: toNum(o.close)
  };
  const last = arr[arr.length - 1];
  if (last && last.open_time === epoch) {
    arr[arr.length - 1] = rec;
  } else {
    arr.push(rec);
  }
  return arr;
}

/** Active symbols and UI population */
const MARKET_NAMES = {
  forex: 'Forex',
  synthetic_index: 'Synthetic Indices',
  commodities: 'Commodities',
  stock_indices: 'Indices',
  cryptocurrencies: 'Cryptocurrencies',
  random_index: 'Random Indices',
};

async function fetchActiveSymbols() {
  const resp = await sendRequest({ active_symbols: 'full' });
  const list = resp.active_symbols || [];
  symbolsAll = list
    .filter(s => s.is_trading !== false)
    .map(s => ({
      symbol: s.symbol,
      display_name: s.display_name,
      market: s.market,
      submarket: s.submarket,
      exchange_is_open: s.exchange_is_open
    }));
  populateMarkets();
  applyMarketFilter();
}

function populateMarkets() {
  const sel = el('marketFilter');
  const markets = Array.from(new Set(symbolsAll.map(s => s.market))).sort();
  sel.innerHTML = '';
  const optAll = document.createElement('option');
  optAll.value = ''; optAll.textContent = 'All Markets';
  sel.appendChild(optAll);
  for (const m of markets) {
    const opt = document.createElement('option');
    opt.value = m;
    opt.textContent = MARKET_NAMES[m] || (m ? m.replace('_',' ').replace(/\b\w/g, c => c.toUpperCase()) : 'Unknown');
    sel.appendChild(opt);
  }
  sel.addEventListener('change', applyMarketFilter);
  sel.value = markets.includes('forex') ? 'forex' : '';
}

function applyMarketFilter() {
  const market = el('marketFilter').value;
  filteredSymbols = symbolsAll.filter(s => !market || s.market === market);
  populateSymbolSelect();
}

function populateSymbolSelect() {
  const sel = el('symbol');
  sel.innerHTML = '';
  for (const s of filteredSymbols) {
    const opt = document.createElement('option');
    opt.value = s.symbol;
    opt.textContent = `${s.display_name} (${s.symbol})`;
    sel.appendChild(opt);
  }
  el('universeCount').textContent = `Filtered symbols: ${filteredSymbols.length}`;
  const defaultSym = filteredSymbols.find(s => s.symbol === 'frxEURUSD') || filteredSymbols[0];
  if (defaultSym) sel.value = defaultSym.symbol;
}

/** One-shot candles for scanning */
async function fetchCandlesOnce(symbol, granularity, count) {
  const req = {
    ticks_history: symbol,
    end: 'latest',          // last N candles up to now
    count,
    granularity,
    style: 'candles'
  };
  const resp = await sendRequest(req);
  return normalizeCandles(resp.candles || []);
}

/** Helpers for SL computation */
function getSymbolMeta(sym) {
  return symbolsAll.find(s => s.symbol === sym);
}
function bufferMultForMarket(mkt) {
  switch (mkt) {
    case 'forex': return 0.8;
    case 'cryptocurrencies': return 1.2;
    case 'synthetic_index': return 1.7;
    case 'random_index': return 1.7;
    case 'stock_indices': return 1.2;
    case 'commodities': return 1.0;
    default: return 1.0;
  }
}

/** Compute Suggested SL + R:R */
function computeSuggestedSL() {
  if (!confluence || !ltfCandles.length) return null;
  const type = confluence.type;
  const startT = confluence.time;
  const endT = bosState?.breakCandle?.open_time || ltfCandles[ltfCandles.length - 1].open_time;

  const left = Number(el('fractL').value);
  const right = Number(el('fractR').value);
  const { highs, lows } = findFractals(ltfCandles, left, right);

  let swing = null;
  if (type === 'long') {
    const cands = lows.filter(x => x.time >= startT && x.time <= endT);
    swing = cands.length ? cands[cands.length - 1] : null;
  } else {
    const cands = highs.filter(x => x.time >= startT && x.time <= endT);
    swing = cands.length ? cands[cands.length - 1] : null;
  }

  const winCandles = ltfCandles.filter(c => c.open_time >= startT && c.open_time <= endT);
  if (!swing && winCandles.length) {
    if (type === 'long') {
      const minLo = Math.min(...winCandles.map(c => toNum(c.low)));
      swing = { price: minLo, time: endT };
    } else {
      const maxHi = Math.max(...winCandles.map(c => toNum(c.high)));
      swing = { price: maxHi, time: endT };
    }
  }

  const atrArr = ATR(ltfCandles, 14);
  const atr = atrArr[atrArr.length - 1];
  if (!swing || atr == null || !isFinite(atr)) return null;

  const meta = getSymbolMeta(htfParams?.symbol || ltfParams?.symbol);
  const mkt = meta?.market;
  const mult = bufferMultForMarket(mkt);
  const buffer = mult * atr;

  const sl = type === 'long' ? (swing.price - buffer) : (swing.price + buffer);
  const entry = bosState?.broken ? toNum(bosState.breakCandle.close) : null;
  const tp = confluence.tpMid;

  let rr = null;
  if (entry != null && tp != null) {
    const reward = Math.abs(tp - entry);
    const risk = type === 'long' ? Math.max(entry - sl, 0) : Math.max(sl - entry, 0);
    rr = risk > 0 ? reward / risk : null;
  }

  return { sl, entry, rr, atr, buffer, mult, market: mkt, swingPrice: swing.price };
}

/** Evaluation pipeline (live streaming) */
function evaluate() {
  const params = {
    bbPeriod: Number(el('bbPeriod').value),
    bbMult: Number(el('bbMult').value),
    rsiLen: Number(el('rsiLen').value),
    stochLen: Number(el('stochLen').value),
    kLen: Number(el('kLen').value),
    dLen: Number(el('dLen').value),
    obLevel: Number(el('obLevel').value),
    osLevel: Number(el('osLevel').value),
  };
  if (htfCandles.length > 0) {
    const res = detectHTFConfluence(htfCandles, params);
    const last = htfCandles[htfCandles.length - 1];
    const lastIdx = htfCandles.length - 1;
    const bb = res.bb;
    const st = res.st;
    el('bbVals').textContent = `${fmt(bb.lower[lastIdx])} / ${fmt(bb.ma[lastIdx])} / ${fmt(bb.upper[lastIdx])}`;
    el('stochVals').textContent = `${fmt(st.k[lastIdx])} / ${fmt(st.d[lastIdx])}`;
    const sym = el('symbol').value;
    const htfG = Number(el('htf').value);
    el('htfNote').textContent = `Symbol: ${sym} @ HTF ${htfG}s | Latest close: ${fmt(last.close)} @ ${epochToStr(last.open_time)}`;

    if (res.found) {
      confluence = { ...res.found, tpMid: res.found.bbMid };
      el('confluenceStatus').innerHTML = `<span class="badge green">Confluence: ${confluence.type.toUpperCase()} @ ${epochToStr(confluence.time)}</span>`;
      el('bias').textContent = confluence.type === 'long' ? 'Long bias âœ…' : 'Short bias âœ…';
      el('tpMid').textContent = fmt(confluence.tpMid);
      el('confluence-badge').textContent = confluence.type.toUpperCase();
    } else {
      el('confluenceStatus').innerHTML = `<span class="badge yellow">Waiting for confluence</span>`;
      el('bias').textContent = 'Neutral';
      el('tpMid').textContent = 'â€”';
      el('confluence-badge').textContent = 'Pending';
      confluence = null;
    }
  }

  const lParams = {
    fractL: Number(el('fractL').value),
    fractR: Number(el('fractR').value),
  };

  if (confluence && ltfCandles.length > 0) {
    const bos = detectLTFBoS(ltfCandles, lParams, confluence);
    bosState = bos.state;

    if (!bosState || !bosState.exists) {
      el('swingRef').textContent = 'â€”';
      el('bosStatus').innerHTML = `<span class="badge yellow">Waiting for HTF confluence or swing ref</span>`;
      el('breakLevel').textContent = 'â€”';
      el('breakTime').textContent = 'â€”';
      el('bos-badge').textContent = 'Waiting';
      el('ltfNote').textContent = bosState?.note || 'â€”';

      // Suggested SL still possible (pre-break)
      const sug = computeSuggestedSL();
      if (sug) {
        el('sugSL').textContent = fmt(sug.sl);
        el('entryPrice').textContent = 'â€”';
        el('rrVal').textContent = 'â€”';
        el('slNote').textContent = `Buffer: ${sug.mult} Ã— ATR(14)=${fmt(sug.atr)} | Swing: ${fmt(sug.swingPrice)} | Market: ${sug.market || 'n/a'}`;
      } else {
        el('sugSL').textContent = 'â€”';
        el('entryPrice').textContent = 'â€”';
        el('rrVal').textContent = 'â€”';
        el('slNote').textContent = 'â€”';
      }
    } else {
      const currLTF = ltfCandles[ltfCandles.length - 1];
      const dir = bosState.type === 'long' ? 'â†‘ Above' : 'â†“ Below';
      el('swingRef').textContent = `${dir.includes('Above') ? 'Swing High' : 'Swing Low'}: ${fmt(bosState.level)} @ ${epochToStr(bosState.ref.time)}`;
      if (bosState.broken) {
        el('bosStatus').innerHTML = `<span class="badge green">BoS Confirmed (${bosState.type.toUpperCase()})</span>`;
        el('breakLevel').textContent = fmt(bosState.level);
        el('breakTime').textContent = epochToStr(bosState.breakCandle.open_time);
        el('bos-badge').textContent = 'Confirmed';
        el('ltfNote').textContent = bosState.type === 'long'
          ? `Structure broke above ${fmt(bosState.level)} after HTF oversold confluence.`
          : `Structure broke below ${fmt(bosState.level)} after HTF overbought confluence.`;
      } else {
        el('bosStatus').innerHTML = `<span class="badge">Waiting for close ${dir} ${fmt(bosState.level)}</span>`;
        el('breakLevel').textContent = fmt(bosState.level);
        el('breakTime').textContent = 'â€”';
        el('bos-badge').textContent = 'Waiting';
        el('ltfNote').textContent = `Monitor price for a ${dir} ${fmt(bosState.level)} close.`;
      }
      el('currPrice').textContent = fmt(currLTF.close);

      // Suggested SL + R:R
      const sug = computeSuggestedSL();
      if (sug) {
        el('sugSL').textContent = fmt(sug.sl);
        el('entryPrice').textContent = sug.entry != null ? fmt(sug.entry) : 'â€”';
        el('rrVal').textContent = sug.rr != null ? `${sug.rr.toFixed(2)}R` : 'â€”';
        el('slNote').textContent = `Buffer: ${sug.mult} Ã— ATR(14)=${fmt(sug.atr)} | Swing: ${fmt(sug.swingPrice)} | Market: ${sug.market || 'n/a'}`;
      } else {
        el('sugSL').textContent = 'â€”';
        el('entryPrice').textContent = 'â€”';
        el('rrVal').textContent = 'â€”';
        el('slNote').textContent = 'â€”';
      }
    }
  } else {
    // No confluence or no LTF data yet
    if (!confluence) {
      el('bosStatus').innerHTML = `<span class="badge">Waiting for HTF confluence</span>`;
      el('swingRef').textContent = 'â€”';
      el('breakLevel').textContent = 'â€”';
      el('breakTime').textContent = 'â€”';
      el('bos-badge').textContent = 'Waiting';
      el('ltfNote').textContent = 'â€”';
      el('sugSL').textContent = 'â€”';
      el('entryPrice').textContent = 'â€”';
      el('rrVal').textContent = 'â€”';
      el('slNote').textContent = 'â€”';
    }
    if (ltfCandles.length > 0) {
      const currLTF = ltfCandles[ltfCandles.length - 1];
      el('currPrice').textContent = fmt(currLTF.close);
    }
  }
}

/** UI actions (live streaming) */
function start() {
  const symbol = el('symbol').value.trim();
  const htf = Number(el('htf').value);
  const ltf = Number(el('ltf').value);
  const histCount = Number(el('histCount').value);

  if (!symbol) {
    alert('Please select a symbol');
    return;
  }
  // reset UI
  confluence = null;
  bosState = null;
  htfCandles = [];
  ltfCandles = [];
  el('bbVals').textContent = 'â€”';
  el('stochVals').textContent = 'â€”';
  el('confluenceStatus').innerHTML = `<span class="badge yellow">Waiting for confluence</span>`;
  el('bias').textContent = 'Neutral';
  el('tpMid').textContent = 'â€”';
  el('confluence-badge').textContent = 'Pending';
  el('swingRef').textContent = 'â€”';
  el('bosStatus').innerHTML = `<span class="badge">Waiting for HTF confluence</span>`;
  el('breakLevel').textContent = 'â€”';
  el('breakTime').textContent = 'â€”';
  el('bos-badge').textContent = 'Waiting';
  el('currPrice').textContent = 'â€”';
  el('htfNote').textContent = 'â€”';
  el('ltfNote').textContent = 'â€”';
  el('sugSL').textContent = 'â€”';
  el('entryPrice').textContent = 'â€”';
  el('rrVal').textContent = 'â€”';
  el('slNote').textContent = 'â€”';

  htfParams = { symbol, granularity: htf, histCount };
  ltfParams = { symbol, granularity: ltf, histCount };

  clearSubs();
  subscribeCandles(symbol, htf, histCount, 'HTF');
  subscribeCandles(symbol, ltf, histCount, 'LTF');
}

function stop() {
  clearSubs();
  log('Stopped all subscriptions.');
}

/** Autoscan engine */
function updateScanKPIs() {
  el('scanLast').textContent = scanStats.last ? new Date(scanStats.last).toLocaleTimeString() : 'â€”';
  el('scanCount').textContent = String(scanStats.count);
  el('scanFound').textContent = String(scanStats.found);
}

function setScanStatus(state) {
  const badge = el('scanStatus');
  if (state === 'running') {
    badge.innerHTML = '<span class="status-dot ok"></span>Running';
    badge.className = 'badge';
  } else if (state === 'idle') {
    badge.innerHTML = '<span class="status-dot warn"></span>Idle';
    badge.className = 'badge yellow';
  } else {
    badge.innerHTML = '<span class="status-dot err"></span>Stopped';
    badge.className = 'badge red';
  }
}

function renderScanTable() {
  const tbody = el('scanTableBody');
  const rows = Object.values(scanResults)
    .sort((a,b) => {
      const scoreA = (a.bos ? 2 : 1);
      const scoreB = (b.bos ? 2 : 1);
      if (scoreA !== scoreB) return scoreB - scoreA;
      return (b.updated || 0) - (a.updated || 0);
    })
    .map(r => {
      const bosPill = r.bos
        ? `<span class="pill green">Confirmed</span>`
        : `<span class="pill yellow">Waiting</span>`;
      const biasTxt = r.bias ? (r.bias === 'long' ? 'LONG' : 'SHORT') : 'â€”';
      const biasPill = r.bias ? `<span class="pill ${r.bias==='long'?'green':'red'}">${biasTxt}</span>` : 'â€”';
      return `<tr>
        <td class="nowrap">${r.display || r.symbol}</td>
        <td>${biasPill}</td>
        <td class="nowrap">${epochToStr(r.time) || 'â€”'}</td>
        <td>${fmt(r.tpMid)}</td>
        <td>${bosPill}</td>
        <td>${r.breakLevel ? fmt(r.breakLevel) : 'â€”'}</td>
        <td class="nowrap">${r.updated ? new Date(r.updated).toLocaleTimeString() : 'â€”'}</td>
        <td><span class="link" data-golive="${r.symbol}">Go Live</span></td>
      </tr>`;
    }).join('');
  tbody.innerHTML = rows || `<tr><td colspan="8" class="muted">No signals yet.</td></tr>`;
}

async function scanOnce() {
  const htf = Number(el('htf').value);
  const ltf = Number(el('ltf').value);
  const histCount = Number(el('histCount').value);
  const max = Number(el('scanMax').value);
  const params = {
    bbPeriod: Number(el('bbPeriod').value),
    bbMult: Number(el('bbMult').value),
    rsiLen: Number(el('rsiLen').value),
    stochLen: Number(el('stochLen').value),
    kLen: Number(el('kLen').value),
    dLen: Number(el('dLen').value),
    obLevel: Number(el('obLevel').value),
    osLevel: Number(el('osLevel').value),
  };
  const lParams = {
    fractL: Number(el('fractL').value),
    fractR: Number(el('fractR').value),
  };

  const universe = filteredSymbols.slice(0, max);
  scanStats.count = 0;
  let found = 0;

  for (const s of universe) {
    if (!scanRunning) break;
    try {
      const h = await fetchCandlesOnce(s.symbol, htf, histCount);
      if (!h.length) continue;
      const hRes = detectHTFConfluence(h, params);
      if (hRes.found) {
        const l = await fetchCandlesOnce(s.symbol, ltf, histCount);
        const bos = detectLTFBoS(l, lParams, { ...hRes.found });
        const bosState = bos?.state;
        scanResults[s.symbol] = {
          symbol: s.symbol,
          display: s.display_name,
          bias: hRes.found.type,
          time: hRes.found.time,
          tpMid: hRes.found.bbMid,
          bos: !!(bosState && bosState.exists && bosState.broken),
          breakLevel: bosState?.level,
          breakTime: bosState?.breakCandle?.open_time,
          updated: Date.now()
        };
        found++;
        renderScanTable();
      }
    } catch (e) {
      log('Scan error', s.symbol, e?.message || e);
    }
    scanStats.count++;
    await sleep(250); // polite pacing
  }
  scanStats.found = found;
  scanStats.last = Date.now();
  updateScanKPIs();
  renderScanTable();
}

function startAutoscan() {
  if (scanRunning) return;
  scanRunning = true;
  setScanStatus('running');
  (async function loop() {
    if (!scanRunning) return;
    await scanOnce();
    const interval = Math.max(10, Number(el('scanInterval').value)) * 1000;
    if (!scanRunning) return;
    scanTimer = setTimeout(loop, interval);
  })();
}

function stopAutoscan() {
  scanRunning = false;
  if (scanTimer) clearTimeout(scanTimer);
  scanTimer = null;
  setScanStatus('idle');
}

/** Events */
el('startBtn').addEventListener('click', start);
el('stopBtn').addEventListener('click', () => { stop(); });
el('scanStartBtn').addEventListener('click', startAutoscan);
el('scanStopBtn').addEventListener('click', stopAutoscan);
document.getElementById('scanTableBody').addEventListener('click', (e) => {
  const sym = e.target?.dataset?.golive;
  if (sym) {
    el('symbol').value = sym;
    stopAutoscan();
    start();
  }
});

/** Init */
setConn('connecting');
ensureWS();

// Keep connection alive
setInterval(() => {
  if (isOpen) {
    try { ws.send(JSON.stringify({ ping: 1 })); } catch {}
  }
}, 30000);
</script>
</body>
</html>
