<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>VinceVision — Deriv API Signals (HTF + LTF Confluence) (+254742850266)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    :root { --bg:#0f1420; --panel:#161d2e; --muted:#7b8aa3; --text:#e7edf7; --green:#21c77a; --red:#ff5b5b; --yellow:#ffce54; --blue:#3aa3ff; }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#0f1420;color:var(--text)}
    header{padding:14px 18px;border-bottom:1px solid #202a3f;background:#0f1420d0;backdrop-filter:blur(6px);position:sticky;top:0;z-index:9}
    h1{margin:0;font-size:18px}
    .tz-badge{font-size:12px;color:#a8b6d3;margin-left:6px}
    .wrap{display:grid;grid-template-columns:360px 1fr;gap:14px;padding:14px}
    @media(max-width:980px){.wrap{grid-template-columns:1fr}}
    .panel{background:var(--panel);border:1px solid #202a3f;border-radius:12px;padding:14px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
    .panel h3{margin:0 0 10px;font-size:14px;color:#c5d1ea}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    input,select,button{width:100%;padding:8px 10px;background:#0f1420;border:1px solid #26324b;color:var(--text);border-radius:8px;outline:none}
    input[type="checkbox"]{width:auto;vertical-align:middle}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
    .btn-primary{background:linear-gradient(135deg,#2b8cff,#1e6fe3);border:none;font-weight:600;cursor:pointer}
    .btn-ghost{background:transparent;border:1px solid #344464;cursor:pointer}
    .badges{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .badge{padding:6px 10px;border-radius:999px;font-size:12px;border:1px solid #2a3752;color:#cdd8ee;display:inline-flex;align-items:center;gap:6px}
    .dot{width:8px;height:8px;border-radius:50%}.dot.green{background:var(--green)}.dot.red{background:var(--red)}.dot.blue{background:var(--blue)}
    #chart{height:520px} #stochChart{height:140px;margin-top:8px}
    .cards{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:10px}
    .card{background:#0f1420;border:1px dashed #2a3752;border-radius:12px;padding:12px}
    .card h4{margin:0 0 6px;font-size:12px;color:#a8b6d3}
    .value{font-size:18px;font-weight:700}
    .value.buy{color:var(--green)} .value.sell{color:var(--red)} .value.flat{color:#b9c6e2}
    table{width:100%;border-collapse:collapse;margin-top:8px;font-size:12px}
    th,td{border-bottom:1px solid #203050;padding:6px 4px;text-align:left;color:#cfd9ef}
    th{color:#93a7ca;font-weight:600}
    .hint{color:#9db2d8;font-size:12px;margin-top:8px;line-height:1.35}
    footer{padding:12px 16px;color:#9fb0d3;font-size:12px;opacity:.9}
    .perf{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:10px}
    .perf .metric{background:#0f1420;border:1px solid #2a3752;border-radius:12px;padding:12px}
    .metric h5{margin:0 0 6px;font-size:12px;color:#a8b6d3}
    .metric .big{font-size:20px;font-weight:800}
    .tag{display:inline-block;padding:2px 8px;border-radius:999px;font-size:11px}
    .tag.win{background:rgba(33,199,122,.15);color:#8af5bf;border:1px solid rgba(33,199,122,.4)}
    .tag.loss{background:rgba(255,91,91,.12);color:#ffb1b1;border:1px solid rgba(255,91,91,.35)}
    .tag.open{background:rgba(120,140,170,.15);color:#cbd8f0;border:1px solid rgba(120,140,170,.35)}
    @media (max-width: 600px) {
      .panel { padding: 10px; }
      .wrap { padding: 8px; grid-template-columns: 1fr; }
      .panel h3 { cursor: pointer; }
      .panel.collapsed > *:not(h3) { display: none; }
    }
    .theme-toggle { position: absolute; right: 18px; top: 14px; }
    :root.light { --bg: #f5f7fa; --panel: #ffffff; --text: #1a2a44; --muted: #6b7280; }
    .tooltip { position: relative; }
    .tooltip:hover::after {
      content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
      background: #1e2a44; color: #fff; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap; z-index: 10;
    }
    /* Fancy button: only the "CRT V2.html" link */
header a[href="CRT V2.html"] {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 14px;
  margin-left: 10px;
  border-radius: 999px;
  background: linear-gradient(135deg, #2b8cff, #8b5cf6 60%, #22d3ee);
  color: #fff !important;
  border: 1px solid rgba(255,255,255,.15);
  text-decoration: none;
  letter-spacing: .2px;
  box-shadow: 0 8px 24px rgba(43,140,255,.35), inset 0 1px 0 rgba(255,255,255,.25);
  transition: transform .15s ease, box-shadow .25s ease, background .3s ease;
}

header a[href="CRT V2.html"]::before {
  content: '';
  position: absolute;
  top: 0; left: -150%;
  width: 50%; height: 100%;
  background: linear-gradient(120deg, transparent, rgba(255,255,255,.35), transparent);
  transform: skewX(-20deg);
  transition: left .6s ease;
}

header a[href="CRT V2.html"]::after {
  content: '↗';
  font-size: 12px;
  opacity: .9;
}

header a[href="CRT V2.html"]:hover {
  transform: translateY(-1px);
  box-shadow: 0 12px 28px rgba(43,140,255,.45), 0 0 0 3px rgba(58,163,255,.2);
}

header a[href="CRT V2.html"]:hover::before {
  left: 150%;
}

header a[href="CRT V2.html"]:active {
  transform: translateY(0);
  box-shadow: 0 6px 18px rgba(43,140,255,.4);
}

header a[href="CRT V2.html"]:focus-visible {
  outline: none;
  box-shadow: 0 0 0 2px rgba(255,255,255,.25), 0 0 0 6px rgba(58,163,255,.45);
}
  </style>
</head>
<body>
  <header>
    <h1>VinceVision — Deriv API Signals|+254742850266
      <span id="tzBadge" class="tz-badge"></span>
      
      <a href="CRT V2.html" target="_blank">CRT TRADING</a>
      
      <a href="CONFIRMATION.html" target="_blank">CONFIRM HERE</a>

       <a href="CRT.html" target="_blank">CRT TRADING</a>
    </h1>
  </header>

  <div class="wrap">
    <!-- Controls -->
    <div class="panel">
      <h3>Deriv connection</h3>
      <label>Deriv App ID</label>
      <input id="appId" value="1089" />
      <label>Symbol (Deriv)</label>
      <input id="symbol" value="frxEURUSD" placeholder="Examples: frxEURUSD, EURUSD, R_100, BOOM300" />

      <div class="row">
        <div>
          <label>Signal timeframe (HTF)</label>
          <select id="sigTf">
            <option>1m</option><option>3m</option><option>5m</option><option>15m</option>
            <option>30m</option><option selected>1h</option><option>2h</option><option>4h</option><option>8h</option><option>1d</option>
          </select>
        </div>
        <div>
          <label>Confluence timeframe (LTF)</label>
          <select id="ltf">
            <option value="none" selected>None</option>
            <option>1m</option><option>3m</option><option>5m</option><option>15m</option><option>30m</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div><label>HTF candles to load</label><input id="limit" type="number" min="200" max="1500" value="700" /></div>
        <div><label>Auto-refresh (sec) — fallback</label><input id="refreshSec" type="number" min="0" value="0" /></div>
      </div>

      <h3>Indicators (HTF per strategy)</h3>
      <div class="grid3">
        <div><label class="tooltip" data-tooltip="Period for Bollinger Bands calculation">BB length</label><input id="bbLen" type="number" value="20" /></div>
        <div><label>BB mult</label><input id="bbMult" type="number" step="0.1" value="2" /></div>
        <div><label>3MA length</label><input id="ma3" type="number" value="3" /></div>
      </div>
      <div class="grid3">
        <div><label>RSI length</label><input id="rsiLen" type="number" value="14"/></div>
        <div><label>Stoch length</label><input id="stochLen" type="number" value="16"/></div>
        <div><label>%K,%D</label><input id="kd" value="3,3"/></div>
      </div>
      <div class="row">
        <div><label>Overbought (HTF)</label><input id="ob" type="number" value="80"/></div>
        <div><label>Oversold (HTF)</label><input id="os" type="number" value="20"/></div>
      </div>
      <div class="row">
        <div><label>Band tap lookback (HTF)</label><input id="tapLookback" type="number" value="2"/></div>
        <div><label>Require HTF Stoch cross</label><select id="requireCross"><option value="true" selected>Yes</option><option value="false">No</option></select></div>
      </div>

      <h3>LTF confluence (optional)</h3>
      <div class="row">
        <div><label>Require LTF mid-band break</label><select id="ltfMidBreak"><option value="true" selected>Yes</option><option value="false">No</option></select></div>
        <div><label>LTF lookback bars</label><input id="ltfLookback" type="number" value="3"/></div>
      </div>
      <div class="row">
        <div><label>Require LTF Stoch range</label><select id="ltfRangeOn"><option value="true" selected>Yes</option><option value="false">No</option></select></div>
        <div><label>Ranges</label><input value="S:65–70 • B:30–50" readonly /></div>
      </div>

      <label><input id="intrabar" type="checkbox" checked /> Show LIVE intrabar signals (unconfirmed)</label>
      <label><input id="todayOnly" type="checkbox" /> Show only today’s confirmed signals</label>
      <label><input type="checkbox" id="toggleBB" checked> Show Bollinger Bands</label>
      <label><input type="checkbox" id="toggleMA3" checked> Show 3MA</label>
      <label><input type="checkbox" id="useATR"> Use ATR-based TP/SL</label>
      <div class="row">
        <div><label>ATR Length</label><input id="atrLen" type="number" value="14"/></div>
        <div><label>ATR Multiplier</label><input id="atrMult" type="number" step="0.1" value="2"/></div>
      </div>
      <label><input type="checkbox" id="useMACD"> Require MACD confirmation</label>
      <div class="row">
        <div><label>Backtest Start Date</label><input id="backtestStart" type="date"/></div>
        <div><label>Backtest End Date</label><input id="backtestEnd" type="date"/></div>
      </div>
      <button id="runBacktest" class="btn-primary">Run Backtest</button>

      <div class="badges">
        <span class="badge"><span class="dot red"></span>Sell (HTF): upper tap + close < 3MA + StochRSI cross down from OB</span>
        <span class="badge"><span class="dot green"></span>Buy (HTF): lower tap + close > 3MA + StochRSI cross up from OS</span>
        <span class="badge"><span class="dot blue"></span>TP = mid band • SL = outer band or prior extreme</span>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px;">
        <button id="run" class="btn-primary">Run / Refresh</button>
        <button id="csv" class="btn-ghost">Download signals CSV</button>
      </div>

      <div class="hint">
        Enter your Deriv App ID and symbol (e.g., frxEURUSD, EURUSD, R_100). Realtime via Deriv WebSocket. LIVE shows forming candle; confirmed prints on close.
      </div>
    </div>

    <!-- Charts + Output -->
    <div class="panel">
      <div id="chart"></div>
      <div id="stochChart"></div>

      <div class="cards">
        <div class="card">
          <h4>Current signal</h4>
          <div id="sigNow" class="value flat">—</div>
          <div id="sigNote" style="font-size:12px;color:#9eb2d8;margin-top:6px;">Waiting…</div>
        </div>
        <div class="card">
          <h4>TP / SL (last confirmed)</h4>
          <div id="tpSl" class="value">—</div>
          <div id="tpSlNote" style="font-size:12px;color:#9eb2d8;margin-top:6px;"></div>
        </div>
        <div class="card">
          <h4>Connection</h4>
          <div id="info" class="value">—</div>
          <div id="infoNote" style="font-size:12px;color:#9eb2d8;margin-top:6px;"></div>
        </div>
      </div>

      <h3 style="margin-top:12px;">Recent confirmed signals (HTF)</h3>
      <table id="signalsTable">
        <thead><tr><th>Time</th><th>Side</th><th>Price</th><th>TP</th><th>SL</th><th>TF</th></tr></thead>
        <tbody></tbody>
      </table>

      <h3 style="margin-top:14px;">Trade outcomes (confirmed entries)</h3>
      <div class="perf">
        <div class="metric"><h5>Total trades</h5><div id="mTotal" class="big">—</div></div>
        <div class="metric"><h5>Wins</h5><div id="mWins" class="big">—</div></div>
        <div class="metric"><h5>Losses</h5><div id="mLosses" class="big">—</div></div>
        <div class="metric"><h5>Win rate</h5><div id="mWR" class="big">—</div></div>
      </div>

      <table id="tradesTable">
        <thead>
          <tr><th>Time</th><th>Side</th><th>Entry</th><th>TP</th><th>SL</th><th>Exit</th><th>Result</th><th>Bars</th></tr>
        </thead>
        <tbody></tbody>
      </table>

      <!-- Live trade and Open trades sections -->
      <h3 style="margin-top:14px;">Live trade</h3>
      <div class="card" id="liveTradeCard">
        <div id="liveTradeSide" class="value flat">—</div>
        <div id="liveTradeDetails" style="font-size:12px;color:#9eb2d8;margin-top:6px;">No live setup currently</div>
        <div style="display:flex;gap:8px;margin-top:8px;">
          <button id="copyLiveBtn" class="btn-ghost" style="display:none;">Copy live trade</button>
        </div>
      </div>

      <h3 style="margin-top:14px;">Open trades (active now)</h3>
      <div class="hint">These are signals that have not hit TP or SL yet (shown in your local time).</div>
      <table id="openTradesTable">
        <thead>
          <tr>
            <th>Time</th><th>Side</th><th>Entry</th><th>TP</th><th>SL</th><th>Bars</th><th>Action</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <!-- END -->
    </div>
  </div>

  <footer>
    Educational use only. Not financial advice. Uses Deriv WebSocket API. Do not expose real trading tokens in the browser.
  </footer>

  <script>
    // ===== Timezone helpers =====
    const USER_TZ = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
    document.getElementById('tzBadge').textContent = `Timezone: ${USER_TZ}`;
    const fmtTs = (sec) => new Intl.DateTimeFormat(navigator.language, {
      year:'numeric', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit',
      hour12:false, timeZone: USER_TZ, timeZoneName:'short'
    }).format(new Date(sec*1000));
    const startOfTodaySec = () => { const d=new Date(); d.setHours(0,0,0,0); return Math.floor(d.getTime()/1000); };
    const fmtNum = n => n==null||isNaN(n)?'—' : (n>=1? n.toFixed(4) : n.toFixed(6));

    // ===== Indicators =====
    const sma = (arr, len) => { const out=Array(arr.length).fill(null); let s=0;
      for(let i=0;i<arr.length;i++){ s+=arr[i]; if(i>=len) s-=arr[i-len]; if(i>=len-1) out[i]=s/len; } return out; };
    const rollingStd = (arr,len)=>{ const out=Array(arr.length).fill(null); let s=0,ss=0;
      for(let i=0;i<arr.length;i++){ s+=arr[i]; ss+=arr[i]*arr[i]; if(i>=len){ s-=arr[i-len]; ss-=arr[i-len]*arr[i-len]; }
        if(i>=len-1){ const m=s/len; out[i]=Math.sqrt(Math.max(ss/len - m*m,0)); } } return out; };
    const rsi = (c,len)=>{ const out=Array(c.length).fill(null); let g=0,l=0;
      for(let i=1;i<=len;i++){ const ch=c[i]-c[i-1]; if(ch>=0) g+=ch; else l-=ch; }
      let ag=g/len, al=l/len; out[len]=al===0?100:100-(100/(1+(ag/al)));
      for(let i=len+1;i<c.length;i++){ const ch=c[i]-c[i-1]; const gg=Math.max(ch,0), ll=Math.max(-ch,0);
        ag=(ag*(len-1)+gg)/len; al=(al*(len-1)+ll)/len; out[i]=al===0?100:100-(100/(1+(ag/al))); } return out; };
    const stochRSI = (c,rsiLen=14,stochLen=16,kLen=3,dLen=3)=>{
      const rr=rsi(c,rsiLen); const st=Array(c.length).fill(null); let minQ=[],maxQ=[];
      const pushMin=i=>{while(minQ.length&&rr[minQ.at(-1)]>=rr[i])minQ.pop();minQ.push(i)};
      const pushMax=i=>{while(maxQ.length&&rr[maxQ.at(-1)]<=rr[i])maxQ.pop();maxQ.push(i)};
      for(let i=0;i<c.length;i++){ if(rr[i]==null) continue; pushMin(i); pushMax(i);
        const start=i-stochLen+1; while(minQ.length&&minQ[0]<start) minQ.shift(); while(maxQ.length&&maxQ[0]<start) maxQ.shift();
        if(i>=stochLen-1){ const mn=rr[minQ[0]], mx=rr[maxQ[0]]; st[i]=mx===mn?0:((rr[i]-mn)/(mx-mn))*100; } }
      const k=sma(st,kLen), d=sma(k,dLen); return {k,d};
    };
    const bollinger = (c,len=20,mult=2)=>{ const mid=sma(c,len), sd=rollingStd(c,len);
      const upper=mid.map((m,i)=>m==null||sd[i]==null?null:m+mult*sd[i]);
      const lower=mid.map((m,i)=>m==null||sd[i]==null?null:m-mult*sd[i]);
      return {upper,mid,lower};
    };
    function atr(bars, len=14) {
      const tr = bars.map((b, i) => i === 0 ? 0 : Math.max(
        b.high - b.low,
        Math.abs(b.high - (bars[i-1]?.close ?? b.high)),
        Math.abs(b.low - (bars[i-1]?.close ?? b.low))
      ));
      return sma(tr, len);
    }
    function macd(bars, fast=12, slow=26, signal=9) {
      const ema = (arr, len) => {
        const out = Array(arr.length).fill(null);
        let k = 2 / (len + 1);
        out[len-1] = sma(arr.slice(0, len), len)[len-1];
        for (let i = len; i < arr.length; i++) {
          out[i] = arr[i] * k + out[i-1] * (1 - k);
        }
        return out;
      };
      const fastEMA = ema(bars.map(b => b.close), fast);
      const slowEMA = ema(bars.map(b => b.close), slow);
      const macdLine = fastEMA.map((f, i) => f && slowEMA[i] ? f - slowEMA[i] : null);
      const signalLine = sma(macdLine, signal);
      return { macd: macdLine, signal: signalLine };
    }

    // ===== Deriv helpers =====
    const TF2GRAN = { '1m':60,'3m':180,'5m':300,'15m':900,'30m':1800,'1h':3600,'2h':7200,'4h':14400,'8h':28800,'1d':86400 };
    const toGran = tf => TF2GRAN[tf] ?? 60;

    function sanitizeInputSymbol(s){ return s.replace(/\s/g,'').toUpperCase().replace('/',''); }

    let symbolCache = null;
    async function getSupportedSymbols(appId) {
      if (symbolCache) return symbolCache;
      const ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${appId}`);
      return new Promise((resolve) => {
        ws.onopen = () => ws.send(JSON.stringify({ active_symbols: 'full', product_type: 'basic' }));
        ws.onmessage = (e) => {
          const m = JSON.parse(e.data);
          if (m.msg_type === 'active_symbols') {
            symbolCache = m.active_symbols.map(s => s.symbol.toUpperCase());
            ws.close();
            resolve(symbolCache);
          }
        };
        ws.onerror = () => { ws.close(); resolve([]); };
      });
    }

    async function resolveDerivSymbol(input, appId){
      const clean = sanitizeInputSymbol(input);
      const supported = await getSupportedSymbols(appId);
      if (supported.includes(clean) || supported.includes(`FRX${clean}`)) {
        return clean;
      } else {
        showError(`Invalid symbol: ${clean}. Please check available symbols.`);
        return clean;
      }
    }

    async function fetchDerivCandles(symbol, tf, count, appId){
      try {
        const bars = await new Promise((resolve, reject)=>{
          const ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${appId}`);
          ws.onopen=()=>ws.send(JSON.stringify({
            ticks_history: symbol, end:'latest', count, style:'candles', granularity: toGran(tf)
          }));
          ws.onmessage=(e)=>{
            const msg=JSON.parse(e.data);
            if(msg.error){ reject(new Error(msg.error.message)); ws.close(); return; }
            if(msg.msg_type==='candles'){
              const bars = msg.candles.map(c=>({
                time:+c.epoch, open:+c.open, high:+c.high, low:+c.low, close:+c.close, volume:0
              }));
              resolve(bars); ws.close();
            }
          };
          ws.onerror=()=>{ reject(new Error('WebSocket connection failed')); ws.close(); };
        });
        return bars;
      } catch (err) {
        showError(`Failed to fetch candles: ${err.message}`);
        throw err;
      }
    }

    function subscribeDerivOHLC(symbol, tf, appId, onUpdate){
      const ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${appId}`);
      const gran = toGran(tf);
      ws.onopen=()=>ws.send(JSON.stringify({
        ticks_history: symbol, end:'latest', count: 300, style:'candles', granularity: gran, subscribe:1
      }));
      ws.onmessage=(e)=>{
        const msg=JSON.parse(e.data);
        if(msg.error){ console.error('Deriv error:', msg.error); return; }
        if(msg.msg_type==='ohlc'){
          const c=msg.ohlc;
          onUpdate({
            time:+c.open_time, open:+c.open, high:+c.high, low:+c.low, close:+c.close, completed:c.completed===1
          });
        }
      };
      ws.onerror=()=>{};
      ws.onclose=()=>{};
      return ws;
    }

    // ===== Indicator pack / strategy =====
    let cache = {};
    function indicatorsFor(bars, p){
      const cacheKey = JSON.stringify({ bars: bars.map(b => b.close), params: p });
      if (cache[cacheKey]) return cache[cacheKey];
      const result = { bb: bollinger(bars.map(b=>b.close), p.bbLen, p.bbMult), ma3: sma(bars.map(b=>b.close), p.ma3), ...stochRSI(bars.map(b=>b.close), p.rsiLen, p.stochLen, p.kLen, p.dLen) };
      cache[cacheKey] = result;
      if (Object.keys(cache).length > 10) cache = {};
      return result;
    }
    const withinRange = (v,a,b)=>{ const lo=Math.min(a,b), hi=Math.max(a,b); return v>=lo && v<=hi; };

    function checkLtfConfluence(ltfBars, ltfInd, p, side, htfTime){
      if(!ltfBars || !ltfBars.length) return true;
      let j=ltfBars.length-1; while(j>=0 && ltfBars[j].time>htfTime) j--;
      if(j<0) return false;
      const look=Math.max(1,p.ltfLookback); let midOK=false, rangeOK=false;
      for(let x=j; x>=0 && x>j-look; x--){
        const close=ltfBars[x].close, mid=ltfInd.bb.mid[x], K=ltfInd.k[x], D=ltfInd.d[x];
        if(p.ltfMidBreak){ midOK = midOK || (side==='SELL' ? close<mid : close>mid); } else midOK=true;
        if(p.ltfRangeOn){
          if(side==='SELL'){ rangeOK = rangeOK || ((K!=null&&withinRange(K,65,70))||(D!=null&&withinRange(D,65,70))); }
          else { rangeOK = rangeOK || ((K!=null&&withinRange(K,30,50))||(D!=null&&withinRange(D,30,50))); }
        } else rangeOK=true;
      }
      return midOK && rangeOK;
    }

    function generateHTFSignals(htfBars, htfInd, ltfBars, ltfInd, p){
      const atrValues = atr(htfBars, p.atrLen || 14);
      const macdInd = macd(htfBars);
      const signals=[];
      const highs=htfBars.map(b=>b.high), lows=htfBars.map(b=>b.low);
      for(let i=2;i<htfBars.length-1;i++){
        if(htfInd.bb.mid[i]==null||htfInd.ma3[i]==null||htfInd.k[i]==null||htfInd.d[i]==null) continue;
        let tappedUpper=false, tappedLower=false;
        for(let t=0; t<=p.tapLookback; t++){ const idx=i-t; if(idx<0) break;
          tappedUpper = tappedUpper || (htfInd.bb.upper[idx]!=null && highs[idx]>=htfInd.bb.upper[idx]);
          tappedLower = tappedLower || (htfInd.bb.lower[idx]!=null && lows[idx] <=htfInd.bb.lower[idx]);
        }
        const closeBelow3=htfBars[i].close<htfInd.ma3[i], closeAbove3=htfBars[i].close>htfInd.ma3[i];
        const crossDown=htfInd.k[i-1]>htfInd.d[i-1] && htfInd.k[i]<htfInd.d[i], crossUp=htfInd.k[i-1]<htfInd.d[i-1] && htfInd.k[i]>htfInd.d[i];
        const fromOB=(htfInd.k[i-1]>=p.ob || htfInd.d[i-1]>=p.ob), fromOS=(htfInd.k[i-1]<=p.os || htfInd.d[i-1]<=p.os);
        const crossOKSell=p.requireCross?(crossDown&&fromOB):fromOB;
        const crossOKBuy =p.requireCross?(crossUp  &&fromOS):fromOS;
        const ltfOkSell=checkLtfConfluence(ltfBars, ltfInd, p, 'SELL', htfBars[i].time);
        const ltfOkBuy =checkLtfConfluence(ltfBars, ltfInd, p, 'BUY',  htfBars[i].time);
        const sellCond=tappedUpper && closeBelow3 && crossOKSell && ltfOkSell;
        const buyCond =tappedLower && closeAbove3 && crossOKBuy  && ltfOkBuy;
        const side = sellCond ? 'SELL' : 'BUY';
        const macdConfirm = p.useMACD ? (side === 'BUY' ? macdInd.macd[i] > macdInd.signal[i] : macdInd.macd[i] < macdInd.signal[i]) : true;
        if((sellCond||buyCond) && macdConfirm){
          const entry=htfBars[i].close;
          const atrMult = p.atrMult || 2;
          const tp = p.useATR ? (side === 'BUY' ? entry + atrValues[i] * atrMult : entry - atrValues[i] * atrMult) : htfInd.bb.mid[i];
          const sl = p.useATR ? (side === 'BUY' ? entry - atrValues[i] * atrMult * 1.5 : entry + atrValues[i] * atrMult * 1.5) : (sellCond ? Math.max(htfInd.bb.upper[i], highs[i]) : Math.min(htfInd.bb.lower[i], lows[i]));
          const signal = { time: htfBars[i].time, side, price: entry, tp: tp??null, sl: sl??null, index:i };
          signals.push(signal);
          notifySignal(signal);
        }
      }
      return signals;
    }

    function liveHTFSignal(htfBars, htfInd, ltfBars, ltfInd, p){
      const i=htfBars.length-1; if(i<2) return null;
      const { bb, ma3, k, d } = htfInd; if(bb.mid[i]==null||ma3[i]==null||k[i]==null||d[i]==null) return null;
      let tappedUpper=false, tappedLower=false;
      for(let t=0;t<=p.tapLookback && i-t>=0;t++){
        const idx=i-t;
        tappedUpper = tappedUpper || (bb.upper[idx]!=null && htfBars[idx].high>=bb.upper[idx]);
        tappedLower = tappedLower || (bb.lower[idx]!=null && htfBars[idx].low <=bb.lower[idx]);
      }
      const closeBelow3=htfBars[i].close<ma3[i], closeAbove3=htfBars[i].close>ma3[i];
      const crossDown=k[i-1]>d[i-1] && k[i]<d[i], crossUp=k[i-1]<d[i-1] && k[i]>d[i-1];
      const fromOB=(k[i-1]>=p.ob || d[i-1]>=p.ob), fromOS=(k[i-1]<=p.os || d[i-1]<=p.os);
      const crossOKSell=p.requireCross?(crossDown&&fromOB):fromOB;
      const crossOKBuy =p.requireCross?(crossUp  &&fromOS):fromOS;
      const ltfOkSell=checkLtfConfluence(ltfBars, ltfInd, p, 'SELL', htfBars[i].time);
      const ltfOkBuy =checkLtfConfluence(ltfBars, ltfInd, p, 'BUY',  htfBars[i].time);

      const sellCond=tappedUpper && closeBelow3 && crossOKSell && ltfOkSell;
      const buyCond =tappedLower && closeAbove3 && crossOKBuy  && ltfOkBuy;
      if(!(sellCond||buyCond)) return null;

      const side=sellCond?'SELL':'BUY', entry=htfBars[i].close;

      let tp, sl;
      if (document.getElementById('useATR').checked) {
        const atrValues = atr(htfBars, +document.getElementById('atrLen').value || 14);
        const a = atrValues[i];
        if (a == null || isNaN(a)) return null;
        const m = +document.getElementById('atrMult').value || 2;
        if (side === 'BUY') { tp = entry + a*m; sl = entry - a*m*1.5; }
        else { tp = entry - a*m; sl = entry + a*m*1.5; }
      } else {
        tp = bb.mid[i];
        sl = sellCond?Math.max(bb.upper[i], htfBars[i].high):Math.min(bb.lower[i], htfBars[i].low);
      }
      return { time: htfBars[i].time, side, price: entry, tp: tp??null, sl: sl??null, provisional:true };
    }

    function evaluateTrades(bars, signals){
      const out=[];
      for(const s of signals){
        let exitIdx=null, exitPrice=null, result='OPEN';
        for(let j=s.index+1;j<bars.length;j++){
          const o=bars[j].open, hi=bars[j].high, lo=bars[j].low;
          if(s.side==='BUY'){
            if(o>=s.tp){ exitIdx=j; exitPrice=s.tp; result='WIN'; break; }
            if(o<=s.sl){ exitIdx=j; exitPrice=s.sl; result='LOSS'; break; }
            const hitTP=hi>=s.tp, hitSL=lo<=s.sl;
            if(hitTP && hitSL){ const tpDist=Math.abs(s.tp-o), slDist=Math.abs(o-s.sl);
              if(tpDist<=slDist){ exitIdx=j; exitPrice=s.tp; result='WIN'; } else { exitIdx=j; exitPrice=s.sl; result='LOSS'; } break; }
            if(hitTP){ exitIdx=j; exitPrice=s.tp; result='WIN'; break; }
            if(hitSL){ exitIdx=j; exitPrice=s.sl; result='LOSS'; break; }
          } else {
            if(o<=s.tp){ exitIdx=j; exitPrice=s.tp; result='WIN'; break; }
            if(o>=s.sl){ exitIdx=j; exitPrice=s.sl; result='LOSS'; break; }
            const hitTP=lo<=s.tp, hitSL=hi>=s.sl;
            if(hitTP && hitSL){ const tpDist=Math.abs(o-s.tp), slDist=Math.abs(s.sl-o);
              if(tpDist<=slDist){ exitIdx=j; exitPrice=s.tp; result='WIN'; } else { exitIdx=j; exitPrice=s.sl; result='LOSS'; } break; }
            if(hitTP){ exitIdx=j; exitPrice=s.tp; result='WIN'; break; }
            if(hitSL){ exitIdx=j; exitPrice=s.sl; result='LOSS'; break; }
          }
        }
        out.push({ time:s.time, side:s.side, entry:s.price, tp:s.tp, sl:s.sl, exit:exitPrice, result,
          barsHeld: exitIdx==null?null:(exitIdx-s.index), exitTime: exitIdx==null?null:bars[exitIdx]?.time });
      }
      return out;
    }

    // ===== Charts/UI =====
    let chart,candleSeries,upperSeries,midSeries,lowerSeries,ma3Series;
    let stochChart,kSeries,dSeries,obH,osH;
    function makeCharts(){
      if(chart) return;
      chart = LightweightCharts.createChart(document.getElementById('chart'), {
        layout:{background:{type:'solid',color:'#111729'}, textColor:'#D8E4FF'},
        grid:{vertLines:{color:'#223250'},horzLines:{color:'#223250'}},
        rightPriceScale:{borderVisible:false}, timeScale:{borderVisible:false,timeVisible:true,secondsVisible:false}, localization:{locale:navigator.language}
      });
      candleSeries=chart.addCandlestickSeries({upColor:'#26a69a',downColor:'#ef5350',wickUpColor:'#26a69a',wickDownColor:'#ef5350',borderVisible:false});
      upperSeries=chart.addLineSeries({color:'#ff7aa2',lineWidth:2,priceLineVisible:false});
      midSeries  =chart.addLineSeries({color:'#ffd66b',lineWidth:2,priceLineVisible:false});
      lowerSeries=chart.addLineSeries({color:'#7acefa',lineWidth:2,priceLineVisible:false});
      ma3Series  =chart.addLineSeries({color:'#9cf08d',lineWidth:1,priceLineVisible:false});
      stochChart = LightweightCharts.createChart(document.getElementById('stochChart'), {
        layout:{background:{type:'solid',color:'#0f1420'}, textColor:'#cfe2ff'},
        grid:{vertLines:{color:'#1f2a42'},horzLines:{color:'#1f2a42'}},
        rightPriceScale:{borderVisible:false,scaleMargins:{top:0.12,bottom:0.14}}, timeScale:{borderVisible:false,timeVisible:true}, localization:{locale:navigator.language}
      });
      kSeries=stochChart.addLineSeries({color:'#5bc0ff',lineWidth:2});
      dSeries=stochChart.addLineSeries({color:'#ff9f65',lineWidth:2});
    }
    function setOBOS(ob,os,times){
      if(obH) stochChart.removeSeries(obH); if(osH) stochChart.removeSeries(osH);
      obH=stochChart.addLineSeries({color:'rgba(255,206,84,.4)',lineWidth:1});
      osH=stochChart.addLineSeries({color:'rgba(99,206,84,.4)',lineWidth:1});
      obH.setData(times.map(t=>({time:t,value:ob})));
      osH.setData(times.map(t=>({time:t,value:os})));
    }
    function markersCombined(signals,trades){
      const m=[];
      for(const s of signals){
        m.push({ time:s.time, position:s.side==='BUY'?'belowBar':'aboveBar',
          color:s.side==='BUY'?'#21c77a':'#ff5b5b', shape:s.side==='BUY'?'arrowUp':'arrowDown', text:`${s.side} ${fmtNum(s.price)}` });
      }
      for(const t of trades){
        if(!t.exit||!t.exitTime) continue;
        m.push({ time:t.exitTime, position:t.side==='BUY'?'aboveBar':'belowBar',
          color:t.result==='WIN'?'#21c77a':'#ff5b5b', shape:t.result==='WIN'?'diamond':'circle', text:`${t.result} ${fmtNum(t.exit)}` });
      }
      return m;
    }
    function updateSignalTable(sigs, tf){
      const tbody=document.querySelector('#signalsTable tbody'); tbody.innerHTML='';
      const todayOnly=document.getElementById('todayOnly').checked; const sod=startOfTodaySec();
      const list=todayOnly? sigs.filter(s=>s.time>=sod):sigs;
      list.slice(-20).reverse().forEach(s=>{
        const tr=document.createElement('tr');
        tr.innerHTML=`<td>${fmtTs(s.time)}</td>
                      <td style="color:${s.side==='BUY'?'#21c77a':'#ff6b6b'}">${s.side}</td>
                      <td>${fmtNum(s.price)}</td>
                      <td>${s.tp?fmtNum(s.tp):'—'}</td>
                      <td>${s.sl?fmtNum(s.sl):'—'}</td>
                      <td>${tf}</td>`;
        tbody.appendChild(tr);
      });
    }
    function updateTradesUI(trades){
      const closed=trades.filter(t=>t.result==='WIN'||t.result==='LOSS');
      const wins=closed.filter(t=>t.result==='WIN').length, losses=closed.filter(t=>t.result==='LOSS').length;
      document.getElementById('mTotal').textContent=trades.length;
      document.getElementById('mWins').textContent=wins;
      document.getElementById('mLosses').textContent=losses;
      document.getElementById('mWR').textContent=(wins+losses? (wins/(wins+losses)*100).toFixed(1)+'%':'—');
      const tbody=document.querySelector('#tradesTable tbody'); tbody.innerHTML='';
      trades.slice(-20).reverse().forEach(t=>{
        const tag=t.result==='WIN'?'win':t.result==='LOSS'?'loss':'open';
        const tr=document.createElement('tr');
        tr.innerHTML=`<td>${fmtTs(t.time)}</td>
                      <td style="color:${t.side==='BUY'?'#21c77a':'#ff6b6b'}">${t.side}</td>
                      <td>${fmtNum(t.entry)}</td>
                      <td>${fmtNum(t.tp)}</td>
                      <td>${fmtNum(t.sl)}</td>
                      <td>${t.exit?fmtTs(t.exitTime)+' @ '+fmtNum(t.exit):'—'}</td>
                      <td><span class="tag ${tag}">${t.result}</span></td>
                      <td>${t.barsHeld==null?'—':t.barsHeld}</td>`;
        tbody.appendChild(tr);
      });
    }

    // Helpers for Live/Open UI
    function copyToClipboard(text) {
      try {
        if (navigator.clipboard?.writeText) {
          navigator.clipboard.writeText(text);
          showError('Copied to clipboard');
        } else {
          const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta);
          ta.select(); document.execCommand('copy'); ta.remove();
          showError('Copied to clipboard');
        }
      } catch {}
    }
    function renderLiveUI(live) {
      const sideEl = document.getElementById('liveTradeSide');
      const detailsEl = document.getElementById('liveTradeDetails');
      const btn = document.getElementById('copyLiveBtn');
      if (!sideEl || !detailsEl || !btn) return;
      if (!live) {
        sideEl.className = 'value flat';
        sideEl.textContent = '—';
        detailsEl.textContent = 'No live setup currently';
        btn.style.display = 'none';
        btn.onclick = null;
        return;
      }
      sideEl.className = 'value ' + (live.side === 'BUY' ? 'buy' : 'sell');
      sideEl.textContent = `LIVE: ${live.side}`;
      detailsEl.textContent = `${resolvedSymbol} ${document.getElementById('sigTf').value} • ${fmtTs(live.time)} • Entry ${fmtNum(live.price)} • TP ${fmtNum(live.tp)} • SL ${fmtNum(live.sl)}`;
      btn.style.display = 'inline-block';
      btn.onclick = () => {
        const s = `${resolvedSymbol} ${document.getElementById('sigTf').value} ${live.side}
Entry: ${fmtNum(live.price)}
TP: ${fmtNum(live.tp)}
SL: ${fmtNum(live.sl)}
Time: ${fmtTs(live.time)}`;
        copyToClipboard(s);
      };
    }
    function updateOpenTradesUI(trades) {
      const tbody = document.querySelector('#openTradesTable tbody');
      if (!tbody) return;
      tbody.innerHTML = '';
      const opens = trades.filter(t => t.result === 'OPEN');
      opens.slice(-50).reverse().forEach(t => {
        const tr = document.createElement('tr');
        const copyStr = `${resolvedSymbol} ${document.getElementById('sigTf').value} ${t.side}
Entry: ${fmtNum(t.entry)} | TP: ${fmtNum(t.tp)} | SL: ${fmtNum(t.sl)} | Time: ${fmtTs(t.time)}`;
        tr.innerHTML = `
          <td>${fmtTs(t.time)}</td>
          <td style="color:${t.side==='BUY'?'#21c77a':'#ff6b6b'}">${t.side}</td>
          <td>${fmtNum(t.entry)}</td>
          <td>${fmtNum(t.tp)}</td>
          <td>${fmtNum(t.sl)}</td>
          <td>${t.barsHeld==null?'—':t.barsHeld}</td>
          <td><button class="btn-ghost">Copy</button></td>`;
        const btn = tr.querySelector('button');
        btn.onclick = () => copyToClipboard(copyStr);
        tbody.appendChild(tr);
      });
    }

    function paint(htfBars, htfInd, signals, trades, tf, infoNote){
      const times=htfBars.map(b=>b.time);
      candleSeries.setData(htfBars);
      upperSeries.setData(times.map((t,i)=>({time:t,value:htfInd.bb.upper[i]??null})));
      midSeries.setData(times.map((t,i)=>({time:t,value:htfInd.bb.mid[i]??null})));
      lowerSeries=lowerSeries; // kept to avoid tree-shaking issues
      lowerSeries.setData(times.map((t,i)=>({time:t,value:htfInd.bb.lower[i]??null})));
      ma3Series.setData(times.map((t,i)=>({time:t,value:htfInd.ma3[i]??null})));
      kSeries.setData(times.map((t,i)=>({time:t,value:htfInd.k[i]??null})));
      dSeries.setData(times.map((t,i)=>({time:t,value:htfInd.d[i]??null})));
      setOBOS(params.ob, params.os, times);
      candleSeries.setMarkers(markersCombined(signals, trades));
      updateSignalTable(signals, tf);
      updateTradesUI(trades);
      updateOpenTradesUI(trades);

      const last=signals.at(-1);
      const sigEl=document.getElementById('sigNow'), noteEl=document.getElementById('sigNote');
      const tpEl=document.getElementById('tpSl'), tpNote=document.getElementById('tpSlNote');
      if(last){
        sigEl.className='value ' + (last.side==='BUY'?'buy':'sell');
        sigEl.textContent=last.side;
        noteEl.textContent=`Confirmed @ ${fmtTs(last.time)} • ${resolvedSymbol} • ${tf}`;
        tpEl.textContent=`TP ${fmtNum(last.tp)} | SL ${fmtNum(last.sl)}`;
        tpNote.textContent='TP = mid band (HTF), SL = outer band or prior extreme.';
      } else { sigEl.className='value flat'; sigEl.textContent='No confirmed setup';
        noteEl.textContent='Waiting for a valid HTF setup…'; tpEl.textContent='—'; tpNote.textContent=''; }
      document.getElementById('info').textContent = 'Deriv WebSocket';
      document.getElementById('infoNote').textContent = infoNote;
    }
    function showLive(live){
      if(!live){
        renderLiveUI(null);
        return;
      }
      const sigEl=document.getElementById('sigNow'), noteEl=document.getElementById('sigNote');
      sigEl.className='value ' + (live.side==='BUY'?'buy':'sell');
      sigEl.textContent = `LIVE: ${live.side}`;
      noteEl.textContent = `Unconfirmed • ${resolvedSymbol} ${document.getElementById('sigTf').value} • ${fmtTs(live.time)} • Price ${fmtNum(live.price)} • TP ${fmtNum(live.tp)} • SL ${fmtNum(live.sl)}`;
      renderLiveUI(live);
    }

    // ===== App state & driver =====
    let params={}, htfBars=[], ltfBars=[], htfInd=null, ltfInd=null, resolvedSymbol='—';
    let ws=null, pollTimer=null;
    let lastSignals = [], lastTrades = [];

    async function runOnce(){
      makeCharts();
      const appId=document.getElementById('appId').value.trim()||'1089';
      const rawSymbol=document.getElementById('symbol').value.trim();
      const sigTf=document.getElementById('sigTf').value;
      const ltfSel=document.getElementById('ltf').value;
      const limit=+document.getElementById('limit').value;

      params = {
        bbLen:+document.getElementById('bbLen').value,
        bbMult:+document.getElementById('bbMult').value,
        ma3:+document.getElementById('ma3').value,
        rsiLen:+document.getElementById('rsiLen').value,
        stochLen:+document.getElementById('stochLen').value,
        kLen:+(document.getElementById('kd').value.split(',')[0]||3),
        dLen:+(document.getElementById('kd').value.split(',')[1]||3),
        ob:+document.getElementById('ob').value,
        os:+document.getElementById('os').value,
        tapLookback:+document.getElementById('tapLookback').value,
        requireCross: document.getElementById('requireCross').value==='true',
        ltfMidBreak: document.getElementById('ltfMidBreak').value==='true',
        ltfRangeOn: document.getElementById('ltfRangeOn').value==='true',
        ltfLookback:+document.getElementById('ltfLookback').value,
        useATR: document.getElementById('useATR').checked,
        atrLen: +document.getElementById('atrLen').value,
        atrMult: +document.getElementById('atrMult').value,
        useMACD: document.getElementById('useMACD').checked
      };

      resolvedSymbol = await resolveDerivSymbol(rawSymbol, appId);

      // Fetch HTF + optional LTF history
      htfBars = await fetchDerivCandles(resolvedSymbol, sigTf, limit, appId);
      if(ltfSel!=='none'){ const ltfLimit=Math.min(1500, limit*60);
        ltfBars = await fetchDerivCandles(resolvedSymbol, ltfSel, ltfLimit, appId);
      } else ltfBars=[];

      // Indicators + signals
      htfInd = indicatorsFor(htfBars, params);
      ltfInd = (ltfBars.length? indicatorsFor(ltfBars, params) : null);
      const signals = generateHTFSignals(htfBars, htfInd, ltfBars, ltfInd, params);
      const trades  = evaluateTrades(htfBars, signals);
      lastSignals = signals;
      lastTrades = trades;

      // Expose open trades getter for Telegram
      window.vvGetOpenTrades = function() {
        const t = evaluateTrades(htfBars, lastSignals || []);
        return t.filter(x => x.result === 'OPEN');
      };

      paint(htfBars, htfInd, signals, trades, sigTf, `Symbol: ${resolvedSymbol}`);

      // LIVE preview
      if(document.getElementById('intrabar').checked){
        const live = liveHTFSignal(htfBars, htfInd, ltfBars, ltfInd, params);
        if(live) showLive(live); else renderLiveUI(null);
      }
    }

    function parseDateInput(val, endOfDay = false) {
      if (!val) return null;
      const [y,m,d] = val.split('-').map(Number);
      const dt = new Date(y, m-1, d, endOfDay ? 23 : 0, endOfDay ? 59 : 0, endOfDay ? 59 : 0, endOfDay ? 999 : 0);
      return Math.floor(dt.getTime()/1000);
    }

    async function runBacktest() {
      const start = parseDateInput(document.getElementById('backtestStart').value, false);
      const end = parseDateInput(document.getElementById('backtestEnd').value, true);
      const candles = await fetchDerivCandles(resolvedSymbol, document.getElementById('sigTf').value, 1500, document.getElementById('appId').value);
      const filteredBars = candles.filter(b => (!start || b.time >= start) && (!end || b.time <= end));
      const ind = indicatorsFor(filteredBars, params);
      const signals = generateHTFSignals(filteredBars, ind, ltfBars, ltfInd, params);
      const trades = evaluateTrades(filteredBars, signals);
      updateTradesUI(trades);
      updateOpenTradesUI(trades);
      alert(`Backtest Results: ${trades.length} trades, ${trades.filter(t => t.result === 'WIN').length} wins`);
    }

    function connectWs(){
      if (ws) try { ws.close(); } catch (_) {}
      let reconnectAttempts = 0, maxAttempts = 5;
      function tryConnect() {
        ws = subscribeDerivOHLC(resolvedSymbol, document.getElementById('sigTf').value, document.getElementById('appId').value, (bar)=>{
          if(!htfBars.length){ candleSeries.update(bar); return; }
          const last=htfBars[htfBars.length-1];
          if(bar.time===last.time){ htfBars[htfBars.length-1]=bar; } else { htfBars.push(bar); }

          htfInd = indicatorsFor(htfBars, params);
          candleSeries.update(bar);

          // Live preview + Open trades refresh
          if(document.getElementById('intrabar').checked){
            const live = liveHTFSignal(htfBars, htfInd, ltfBars, ltfInd, params);
            if(live) showLive(live); else renderLiveUI(null);
          }
          if (lastSignals && lastSignals.length) {
            const tradesLive = evaluateTrades(htfBars, lastSignals);
            updateOpenTradesUI(tradesLive);
          }

          if(bar.completed){ runOnce().catch(console.error); }
        });
        ws.onclose = () => {
          if (reconnectAttempts < maxAttempts) {
            setTimeout(() => {
              reconnectAttempts++;
              tryConnect();
            }, Math.min(1000 * 2 ** reconnectAttempts, 30000));
          } else {
            document.getElementById('info').textContent = 'Disconnected';
            document.getElementById('infoNote').textContent = 'Max reconnection attempts reached';
          }
        };
      }
      tryConnect();
    }

    function restartTimer(){
      clearInterval(pollTimer);
      const sec=+document.getElementById('refreshSec').value;
      if(sec>0) pollTimer=setInterval(()=>runOnce().catch(console.error), sec*1000);
    }

    // CSV export (trade report)
    function downloadTradeReport() {
      const trades = evaluateTrades(htfBars, generateHTFSignals(htfBars, htfInd, ltfBars, ltfInd, params));
      const closed = trades.filter(t => t.result === 'WIN' || t.result === 'LOSS');
      const wins = closed.filter(t => t.result === 'WIN').length;
      const header = ['Time', 'Side', 'Entry', 'TP', 'SL', 'Exit', 'Result', 'Bars Held', 'Win Rate'];
      const winRate = closed.length ? (wins / closed.length * 100).toFixed(1) + '%' : '—';
      const rows = trades.map(t => [
        fmtTs(t.time), t.side, fmtNum(t.entry), fmtNum(t.tp), fmtNum(t.sl),
        t.exit ? fmtNum(t.exit) : '—', t.result, t.barsHeld ?? '—', winRate
      ]);
      const csv = [header, ...rows].map(r => r.join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'trade_report.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    function showError(msg) {
      const errDiv = document.createElement('div');
      errDiv.style.cssText = 'position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#ff5b5b;color:#fff;padding:8px 16px;border-radius:8px;z-index:9999;';
      errDiv.textContent = msg;
      document.body.appendChild(errDiv);
      setTimeout(() => errDiv.remove(), 1800);
    }

    function toggleTheme() {
      document.documentElement.classList.toggle('light');
      chart.applyOptions({ layout: { background: { color: document.documentElement.classList.contains('light') ? '#f5f7fa' : '#111729' } } });
      stochChart.applyOptions({ layout: { background: { color: document.documentElement.classList.contains('light') ? '#f5f7fa' : '#0f1420' } } });
    }

    function toggleSeriesVisibility() {
      const showBB = document.getElementById('toggleBB').checked;
      const showMA3 = document.getElementById('toggleMA3').checked;
      upperSeries.applyOptions({ visible: showBB });
      midSeries.applyOptions({ visible: showBB });
      lowerSeries.applyOptions({ visible: showBB });
      ma3Series.applyOptions({ visible: showMA3 });
    }

    function validateInputs() {
      ['bbLen', 'bbMult', 'ma3', 'rsiLen', 'stochLen', 'tapLookback', 'ltfLookback'].forEach(id => {
        const input = document.getElementById(id);
        input.addEventListener('input', () => {
          if (+input.value < 1) { input.value = 1; alert('Value must be positive'); }
        });
      });
      document.getElementById('appId').addEventListener('input', () => {
        if (!/^\d+$/.test(document.getElementById('appId').value)) {
          alert('App ID must be numeric');
          document.getElementById('appId').value = '1089';
        }
      });
    }

    function requestNotificationPermission() {
      if (Notification.permission !== 'granted') {
        Notification.requestPermission();
      }
    }

    function notifySignal(signal) {
      if (Notification.permission === 'granted') {
        new Notification(`New ${signal.side} Signal`, {
          body: `${signal.side} @ ${fmtNum(signal.price)} on ${resolvedSymbol} (${document.getElementById('sigTf').value}) at ${fmtTs(signal.time)}`,
          icon: signal.side === 'BUY' ? '/buy-icon.png' : '/sell-icon.png'
        });
      }
    }

    function debounce(fn, ms) {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), ms);
      };
    }
    const debouncedRun = debounce(() => runOnce().then(connectWs).catch(console.error), 500);

    // UI wiring
    document.getElementById('sigTf').addEventListener('change', debouncedRun);
    document.getElementById('ltf').addEventListener('change', debouncedRun);
    document.getElementById('symbol').addEventListener('change', debouncedRun);
    document.getElementById('symbol').addEventListener('keyup', e=>{ if(e.key==='Enter') debouncedRun(); });
    document.getElementById('appId').addEventListener('change', debouncedRun);
    document.getElementById('refreshSec').addEventListener('change', restartTimer);
    document.getElementById('run').addEventListener('click', ()=>runOnce().then(connectWs).catch(console.error));
    document.getElementById('csv').addEventListener('click', downloadTradeReport);
    ['bbLen','bbMult','ma3','rsiLen','stochLen','kd','ob','os','tapLookback','requireCross','ltfMidBreak','ltfRangeOn','ltfLookback','limit','todayOnly','intrabar','useATR','atrLen','atrMult','useMACD']
      .forEach(id=>document.getElementById(id).addEventListener('change', debouncedRun));
    document.getElementById('toggleBB').addEventListener('change', toggleSeriesVisibility);
    document.getElementById('toggleMA3').addEventListener('change', toggleSeriesVisibility);
    document.getElementById('runBacktest').addEventListener('click', runBacktest);

    // Init
    (async()=>{ makeCharts(); validateInputs(); requestNotificationPermission(); await runOnce(); connectWs(); restartTimer(); })().catch(console.error);
  </script>

  <!-- Discord (unchanged) -->
  <script>
  (function () {
    const cfg = {
      webhook: 'https://discord.com/api/webhooks/1431662464080285736/wiqGZaLuY8gFZ88uH77K6Gj9dEYRiKaHe8X0oBTVZZjoWz5nazb7oteUsv62nPiY55At',
      tickSec: 10,
      includeLive: false,
      repeatDuplicates: false,
      requireVisible: true,
      sendImmediately: true,
      blockBurstOnBoot: true,
      bootQuietMs: 1200,
      mention: ''
    };

    let timer = null;
    let lastSentKey = null;
    let lastLiveSentKey = null;
    const bootTs = Date.now();
    let bootSendTimer = null;

    window._vv_lastConfirmed = window._vv_lastConfirmed || null;
    window._vv_lastLive = window._vv_lastLive || null;

    function fixed(n) { if (n == null || isNaN(n)) return '—'; return Math.abs(n) >= 1 ? Number(n).toFixed(4) : Number(n).toFixed(6); }
    function fmtTime(sec) {
      try {
        return new Intl.DateTimeFormat(navigator.language, {year:'numeric',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false})
          .format(new Date(sec*1000));
      } catch { const d=new Date(sec*1000); return d.toISOString().replace('T',' ').slice(0,19); }
    }
    function getSymbol() {
      return (typeof resolvedSymbol !== 'undefined' && resolvedSymbol && resolvedSymbol !== '—')
        ? resolvedSymbol
        : ((document.getElementById('symbol')?.value || '').trim() || '—');
    }
    function getTf() { return document.getElementById('sigTf')?.value || ''; }

    function parseDateToSec(val, endOfDay = false) {
      if (!val) return null;
      const [y,m,d] = val.split('-').map(Number);
      const dt = endOfDay ? new Date(y, m-1, d, 23,59,59,999) : new Date(y, m-1, d, 0,0,0,0);
      return Math.floor(dt.getTime()/1000);
    }
    function getDateWindow() {
      const sEl = document.getElementById('backtestStart');
      const eEl = document.getElementById('backtestEnd');
      const todayOnly = document.getElementById('todayOnly')?.checked;
      const sVal = sEl?.value || '';
      const eVal = eEl?.value || '';
      if (sVal || eVal) {
        const from = parseDateToSec(sVal, false) ?? parseDateToSec(eVal, false);
        const to   = parseDateToSec(eVal, true)   ?? parseDateToSec(sVal, true);
        return { from, to };
      }
      if (todayOnly) {
        const from = (typeof startOfTodaySec === 'function') ? startOfTodaySec() : Math.floor(new Date(new Date().toDateString()).getTime()/1000);
        return { from, to: null };
      }
      return null;
    }
    function isInWindow(ts) {
      const win = getDateWindow();
      if (!win) return true;
      if (win.from && ts < win.from) return false;
      if (win.to && ts > win.to) return false;
      return true;
    }

    function keyOf(prefix, sig) {
      return `${prefix}|${getSymbol()}|${getTf()}|${sig.time}|${sig.side}|${sig.price}|${sig.tp}|${sig.sl}`;
    }
    function makeEmbed(sig, confirmed) {
      const color = sig.side === 'BUY' ? 3066993 : 15158332;
      return {
        title: `VinceVision Signal — ${confirmed ? 'CONFIRMED' : 'LIVE'}`,
        color,
        fields: [
          { name: 'Market', value: getSymbol(), inline: true },
          { name: 'TF', value: getTf() || '—', inline: true },
          { name: 'Side', value: sig.side || '—', inline: true },
          { name: 'Entry', value: fixed(sig.price), inline: true },
          { name: 'TP', value: fixed(sig.tp), inline: true },
          { name: 'SL', value: fixed(sig.sl), inline: true }
        ],
        footer: { text: `Time: ${fmtTime(sig.time)}` },
        timestamp: new Date(sig.time * 1000).toISOString()
      };
    }
    function makeTradeJson(sig, confirmed) {
      const payload = {
        type: 'signal',
        status: confirmed ? 'confirmed' : 'live',
        order_type: 'market',
        symbol: getSymbol(),
        tf: getTf(),
        side: sig.side,
        entry: Number(sig.price),
        tp: (sig.tp == null ? null : Number(sig.tp)),
        sl: (sig.sl == null ? null : Number(sig.sl)),
        timestamp: Number(sig.time)
      };
      return '```json\n' + JSON.stringify(payload) + '\n```';
    }

    async function sendDiscord(sig, confirmed) {
      if (!cfg.webhook) return;
      if (!isInWindow(sig.time)) return;
      const embed = makeEmbed(sig, confirmed);
      const content = makeTradeJson(sig, confirmed);
      const payload = { content: cfg.mention ? cfg.mention + '\n' + content : content, username: 'VinceVision', embeds: [embed] };
      try {
        const res = await fetch(cfg.webhook, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!res.ok) {
          const t = await res.text().catch(()=> '');
          console.warn('Discord webhook error', res.status, t);
        }
      } catch (e) { console.warn('Discord dispatch failed', e); }
    }

    async function tick() {
      if (cfg.requireVisible && document.hidden) return;
      const confirmed = window._vv_lastConfirmed;
      if (confirmed && isInWindow(confirmed.time)) {
        const key = keyOf('C', confirmed);
        if (cfg.repeatDuplicates || key !== lastSentKey) {
          lastSentKey = key;
          await sendDiscord(confirmed, true);
        }
        return;
      }
      if (cfg.includeLive && window._vv_lastLive && isInWindow(window._vv_lastLive.time)) {
        const live = window._vv_lastLive;
        const keyL = keyOf('L', live);
        if (cfg.repeatDuplicates || keyL !== lastLiveSentKey) {
          lastLiveSentKey = keyL;
          await sendDiscord(live, false);
        }
      }
    }

    function startTimer() { stopTimer(); timer = setInterval(tick, Math.max(1, cfg.tickSec) * 1000); }
    function stopTimer() { if (timer) { clearInterval(timer); timer = null; } }

    const origNotify = window.notifySignal;
    window.notifySignal = function(signal) {
      try { if (typeof origNotify === 'function') origNotify.apply(this, arguments); } catch (e) { console.warn(e); }
      const sinceBoot = Date.now() - bootTs;
      if (cfg.blockBurstOnBoot && sinceBoot < cfg.bootQuietMs) {
        if (isInWindow(signal.time)) window._vv_lastConfirmed = signal;
        if (!bootSendTimer) {
          bootSendTimer = setTimeout(() => {
            const s = window._vv_lastConfirmed;
            if (s && isInWindow(s.time)) {
              lastSentKey = keyOf('C', s);
              sendDiscord(s, true);
            }
            bootSendTimer = null;
          }, cfg.bootQuietMs + 50);
        }
        return;
      }
      window._vv_lastConfirmed = signal;
      if (cfg.sendImmediately && isInWindow(signal.time)) {
        lastSentKey = keyOf('C', signal);
        sendDiscord(signal, true);
      }
    };

    const origShowLive = window.showLive;
    if (typeof origShowLive === 'function') {
      window.showLive = function(live) {
        try { origShowLive.apply(this, arguments); } catch (e) { console.warn(e); }
        window._vv_lastLive = live;
      };
    }

    ['todayOnly','backtestStart','backtestEnd'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('change', () => { lastSentKey = null; lastLiveSentKey = null; });
    });

    window.addEventListener('beforeunload', stopTimer);
    startTimer();
  })();
  </script>

  <!-- Telegram: ONLY send OPEN trades (active now), not past/closed -->
  <script>
  (function () {
    // WARNING: Exposes bot token client-side. For production, proxy via server.
    const tgCfg = {
      enabled: true,
      botToken: '8335488005:AAG8j-mLVpINGhGGKH4UpACPECjKMZNWIB0',
      recipients: ['6812351007', '-1003244408726'],  // user + group
      tickSec: 7,                 // scan cadence
      sendImmediatelyOnConfirm: true,
      requireVisible: false,      // send even if tab hidden
      dedupeLifetimeMs: 24*60*60*1000  // forget sent keys after 24h
    };
    if (!tgCfg.enabled) return;

    const sentKeys = new Map(); // key -> ts

    function pruneDedupe() {
      const now = Date.now();
      for (const [k, ts] of sentKeys) {
        if (now - ts > tgCfg.dedupeLifetimeMs) sentKeys.delete(k);
      }
    }
    function openKey(t) {
      const tf = document.getElementById('sigTf')?.value || '';
      return `O|${typeof resolvedSymbol==='string'?resolvedSymbol:''}|${tf}|${t.time}|${t.side}|${t.entry}|${t.tp}|${t.sl}`;
    }
    function fixed(n) { if (n == null || isNaN(n)) return '—'; return Math.abs(n) >= 1 ? Number(n).toFixed(4) : Number(n).toFixed(6); }
    function buildOpenText(t) {
      const tf = document.getElementById('sigTf')?.value || '';
      return [
        '<b>VinceVision — OPEN TRADE</b>',
        `Market: <b>${typeof resolvedSymbol==='string'?resolvedSymbol:'—'}</b>`,
        `TF: <b>${tf}</b>`,
        `Side: <b>${t.side}</b>`,
        `Entry: <code>${fixed(t.entry)}</code>`,
        `TP: <code>${fixed(t.tp)}</code>`,
        `SL: <code>${fixed(t.sl)}</code>`,
        `Time: <code>${fmtTs(t.time)}</code>`
      ].join('\n');
    }
    async function tgSend(text) {
      const url = `https://api.telegram.org/bot${tgCfg.botToken}/sendMessage`;
      for (const chat_id of tgCfg.recipients) {
        try {
          const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ chat_id, text, parse_mode: 'HTML', disable_web_page_preview: true })
          });
          if (!res.ok) {
            const t = await res.text().catch(()=> '');
            console.warn('Telegram send error', res.status, t);
          }
        } catch (e) { console.warn('Telegram send failed', e); }
      }
    }

    // Optional date filter: respect Backtest window or Today-only if set
    function parseDateToSec(val, endOfDay = false) {
      if (!val) return null;
      const [y,m,d] = val.split('-').map(Number);
      const dt = endOfDay ? new Date(y, m-1, d, 23,59,59,999) : new Date(y, m-1, d, 0,0,0,0);
      return Math.floor(dt.getTime()/1000);
    }
    function inDateWindow(trade) {
      const sEl = document.getElementById('backtestStart');
      const eEl = document.getElementById('backtestEnd');
      const todayOnly = document.getElementById('todayOnly')?.checked;
      const sVal = sEl?.value || '';
      const eVal = eEl?.value || '';
      if (sVal || eVal) {
        const from = parseDateToSec(sVal, false) ?? parseDateToSec(eVal, false);
        const to   = parseDateToSec(eVal, true)   ?? parseDateToSec(sVal, true);
        if (from && trade.time < from) return false;
        if (to && trade.time > to) return false;
        return true;
      }
      if (todayOnly) {
        const d=new Date(); d.setHours(0,0,0,0);
        const from=Math.floor(d.getTime()/1000);
        if (trade.time < from) return false;
      }
      return true;
    }

    async function scanAndSendOpen() {
      if (tgCfg.requireVisible && document.hidden) return;
      pruneDedupe();
      try {
        const getOpens = window.vvGetOpenTrades;
        if (typeof getOpens !== 'function') return;
        const opens = (getOpens() || []).filter(inDateWindow);
        for (const t of opens) {
          const key = openKey(t);
          if (!sentKeys.has(key)) {
            sentKeys.set(key, Date.now());
            await tgSend(buildOpenText(t));
          }
        }
      } catch (e) {
        console.warn('Open-scan error', e);
      }
    }

    // Periodic scan
    const timer = setInterval(scanAndSendOpen, Math.max(3, tgCfg.tickSec) * 1000);
    window.addEventListener('beforeunload', () => clearInterval(timer));

    // Send immediately upon signal confirmation (only if still OPEN)
    if (tgCfg.sendImmediatelyOnConfirm) {
      const origNotify = window.notifySignal;
      window.notifySignal = function(signal) {
        try { if (typeof origNotify === 'function') origNotify.apply(this, arguments); } catch (e) {}
        setTimeout(scanAndSendOpen, 25); // allow state to update
      };
    }

    // Initial scan shortly after load
    setTimeout(scanAndSendOpen, 800);

    // Re-scan when date filters change
    ['todayOnly','backtestStart','backtestEnd','sigTf'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('change', () => { sentKeys.clear(); scanAndSendOpen(); });
    });
  })();
  </script>
</body>
</html>
