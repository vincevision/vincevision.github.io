<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>VinceVision Strategy — HTF Signals + LTF Confluence</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    :root { --bg:#0f1420; --panel:#161d2e; --muted:#7b8aa3; --text:#e7edf7; --green:#21c77a; --red:#ff5b5b; --yellow:#ffce54; --blue:#3aa3ff; }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#0f1420;color:var(--text)}
    header{padding:14px 18px;border-bottom:1px solid #202a3f;background:#0f1420d0;backdrop-filter:blur(6px);position:sticky;top:0;z-index:9}
    h1{margin:0;font-size:18px}
    .tz-badge{font-size:12px;color:#a8b6d3;margin-left:6px}
    .wrap{display:grid;grid-template-columns:340px 1fr;gap:14px;padding:14px}
    @media(max-width:980px){.wrap{grid-template-columns:1fr}}
    .panel{background:var(--panel);border:1px solid #202a3f;border-radius:12px;padding:14px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
    .panel h3{margin:0 0 10px;font-size:14px;color:#c5d1ea}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    input,select,button{width:100%;padding:8px 10px;background:#0f1420;border:1px solid #26324b;color:var(--text);border-radius:8px;outline:none}
    input[type="checkbox"]{width:auto;vertical-align:middle}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
    .btn-primary{background:linear-gradient(135deg,#2b8cff,#1e6fe3);border:none;font-weight:600;cursor:pointer}
    .btn-ghost{background:transparent;border:1px solid #344464;cursor:pointer}
    .badges{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .badge{padding:6px 10px;border-radius:999px;font-size:12px;border:1px solid #2a3752;color:#cdd8ee;display:inline-flex;align-items:center;gap:6px}
    .dot{width:8px;height:8px;border-radius:50%}.dot.green{background:var(--green)}.dot.red{background:var(--red)}.dot.blue{background:var(--blue)}
    #chart{height:520px} #stochChart{height:140px;margin-top:8px}
    .cards{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:10px}
    .card{background:#0f1420;border:1px dashed #2a3752;border-radius:12px;padding:12px}
    .card h4{margin:0 0 6px;font-size:12px;color:#a8b6d3}
    .value{font-size:18px;font-weight:700}
    .value.buy{color:var(--green)} .value.sell{color:var(--red)} .value.flat{color:#b9c6e2}
    table{width:100%;border-collapse:collapse;margin-top:8px;font-size:12px}
    th,td{border-bottom:1px solid #203050;padding:6px 4px;text-align:left;color:#cfd9ef}
    th{color:#93a7ca;font-weight:600}
    .hint{color:#9db2d8;font-size:12px;margin-top:8px;line-height:1.35}
    footer{padding:12px 16px;color:#9fb0d3;font-size:12px;opacity:.9}
    .perf{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:10px}
    .perf .metric{background:#0f1420;border:1px solid #2a3752;border-radius:12px;padding:12px}
    .metric h5{margin:0 0 6px;font-size:12px;color:#a8b6d3}
    .metric .big{font-size:20px;font-weight:800}
    .tag{display:inline-block;padding:2px 8px;border-radius:999px;font-size:11px}
    .tag.win{background:rgba(33,199,122,.15);color:#8af5bf;border:1px solid rgba(33,199,122,.4)}
    .tag.loss{background:rgba(255,91,91,.12);color:#ffb1b1;border:1px solid rgba(255,91,91,.35)}
    .tag.open{background:rgba(120,140,170,.15);color:#cbd8f0;border:1px solid rgba(120,140,170,.35)}
  </style>
</head>
<body>
  <header>
    <h1>VinceVision (HTF) Bollinger + 3MA + StochRSI — Live Signals
      <span id="tzBadge" class="tz-badge"></span>
    </h1>
  </header>

  <div class="wrap">
    <!-- Controls -->
    <div class="panel">
      <h3>Setup</h3>
      <label>Symbol (Binance)</label>
      <input id="symbol" value="BTCUSDT" />

      <div class="row">
        <div>
          <label>Signal timeframe (HTF)</label>
          <select id="sigTf">
            <option>5m</option><option>15m</option><option selected>1h</option><option>4h</option><option>1d</option>
          </select>
        </div>
        <div>
          <label>Confluence timeframe (LTF)</label>
          <select id="ltf">
            <option value="none" selected>None</option>
            <option>1m</option><option>3m</option><option>5m</option><option>15m</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div><label>HTF candles to load</label><input id="limit" type="number" min="150" max="1500" value="600" /></div>
        <div><label>Fallback refresh (sec)</label><input id="refreshSec" type="number" min="0" value="0" /></div>
      </div>

      <h3 style="margin-top:12px;">Indicators (HTF as per rules)</h3>
      <div class="grid3">
        <div><label>BB length</label><input id="bbLen" type="number" value="20" /></div>
        <div><label>BB mult</label><input id="bbMult" type="number" step="0.1" value="2" /></div>
        <div><label>3MA length</label><input id="ma3" type="number" value="3" /></div>
      </div>
      <div class="grid3">
        <div><label>RSI length</label><input id="rsiLen" type="number" value="14"/></div>
        <div><label>Stoch length</label><input id="stochLen" type="number" value="16"/></div>
        <div><label>%K,%D</label><input id="kd" value="3,3"/></div>
      </div>
      <div class="row">
        <div><label>Overbought (HTF)</label><input id="ob" type="number" value="80"/></div>
        <div><label>Oversold (HTF)</label><input id="os" type="number" value="20"/></div>
      </div>
      <div class="row">
        <div><label>HTF tap lookback (candles)</label><input id="tapLookback" type="number" value="2"/></div>
        <div><label>Confirm cross on HTF</label><select id="requireCross"><option value="true" selected>Yes</option><option value="false">No</option></select></div>
      </div>

      <h3 style="margin-top:12px;">LTF confluence (optional)</h3>
      <div class="row">
        <div><label>Require LTF mid-band break</label><select id="ltfMidBreak"><option value="true" selected>Yes</option><option value="false">No</option></select></div>
        <div><label>LTF lookback bars</label><input id="ltfLookback" type="number" value="3"/></div>
      </div>
      <div class="row">
        <div><label>Require LTF Stoch range</label><select id="ltfRangeOn"><option value="true" selected>Yes</option><option value="false">No</option></select></div>
        <div><label>—</label><span style="display:block;color:#8aa2c7;font-size:12px;margin-top:14px;">Sells: 70–65 • Buys: 30–50</span></div>
      </div>

      <label><input id="intrabar" type="checkbox" checked /> Show LIVE intrabar signals (unconfirmed)</label>
      <label><input id="todayOnly" type="checkbox" /> Show only today’s confirmed signals</label>

      <div class="badges">
        <span class="badge"><span class="dot red"></span>Sell (HTF): upper band tap + close below 3MA + StochRSI cross down from OB</span>
        <span class="badge"><span class="dot green"></span>Buy (HTF): lower band tap + close above 3MA + StochRSI cross up from OS</span>
        <span class="badge"><span class="dot blue"></span>TP = HTF mid band • SL = beyond outer band or prior extreme</span>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px;">
        <button id="run" class="btn-primary">Refresh now</button>
        <button id="csv" class="btn-ghost">Download signals CSV</button>
      </div>

      <div class="hint">
        Signals are generated on the HTF you pick. LTF is only for extra confluence (mid-band break + StochRSI in 65–70 or 30–50). Times show in your timezone.
      </div>
    </div>

    <!-- Charts + Output -->
    <div class="panel">
      <div id="chart"></div>
      <div id="stochChart"></div>

      <div class="cards">
        <div class="card">
          <h4>Current signal</h4>
          <div id="sigNow" class="value flat">—</div>
          <div id="sigNote" style="font-size:12px;color:#9eb2d8;margin-top:6px;">Waiting…</div>
        </div>
        <div class="card">
          <h4>TP / SL (last confirmed)</h4>
          <div id="tpSl" class="value">—</div>
          <div id="tpSlNote" style="font-size:12px;color:#9eb2d8;margin-top:6px;"></div>
        </div>
        <div class="card">
          <h4>Info</h4>
          <div id="info" class="value">—</div>
          <div id="infoNote" style="font-size:12px;color:#9eb2d8;margin-top:6px;"></div>
        </div>
      </div>

      <h3 style="margin-top:12px;">Recent confirmed signals (HTF)</h3>
      <table id="signalsTable">
        <thead><tr><th>Time</th><th>Side</th><th>Price</th><th>TP</th><th>SL</th><th>TF</th></tr></thead>
        <tbody></tbody>
      </table>

      <h3 style="margin-top:14px;">Trade outcomes (confirmed entries)</h3>
      <div class="perf">
        <div class="metric"><h5>Total trades</h5><div id="mTotal" class="big">—</div></div>
        <div class="metric"><h5>Wins</h5><div id="mWins" class="big">—</div></div>
        <div class="metric"><h5>Losses</h5><div id="mLosses" class="big">—</div></div>
        <div class="metric"><h5>Win rate</h5><div id="mWR" class="big">—</div></div>
      </div>

      <table id="tradesTable">
        <thead>
          <tr><th>Time</th><th>Side</th><th>Entry</th><th>TP</th><th>SL</th><th>Exit</th><th>Result</th><th>Bars</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <footer>
    Educational use only. Not financial advice. Data via Binance. LIVE signals can change until the candle closes. Times shown in your timezone.
  </footer>

  <script>
    // ==== Timezone helpers ====
    const USER_TZ = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
    document.getElementById('tzBadge').textContent = `Timezone: ${USER_TZ}`;
    const fmtTs = (sec) => new Intl.DateTimeFormat(navigator.language, {
      year:'numeric', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit',
      hour12:false, timeZone: USER_TZ, timeZoneName:'short'
    }).format(new Date(sec*1000));
    const startOfTodaySec = () => { const d=new Date(); d.setHours(0,0,0,0); return Math.floor(d.getTime()/1000); };
    const fmtNum = n => n==null||isNaN(n)?'—' : (n>=1? n.toFixed(2) : n.toFixed(6));

    // ==== Indicators ====
    const sma = (arr, len) => { const out=Array(arr.length).fill(null); let sum=0;
      for (let i=0;i<arr.length;i++){ sum+=arr[i]; if(i>=len) sum-=arr[i-len]; if(i>=len-1) out[i]=sum/len; } return out; };
    const rollingStd = (arr, len) => { const out=Array(arr.length).fill(null); let sum=0,sumSq=0;
      for (let i=0;i<arr.length;i++){ sum+=arr[i]; sumSq+=arr[i]*arr[i];
        if(i>=len){ sum-=arr[i-len]; sumSq-=arr[i-len]*arr[i-len]; }
        if(i>=len-1){ const m=sum/len; out[i]=Math.sqrt(Math.max((sumSq/len)-m*m,0)); } } return out; };
    const rsi = (closes, len) => { const out=Array(closes.length).fill(null);
      let g=0,l=0; for(let i=1;i<=len;i++){ const ch=closes[i]-closes[i-1]; if(ch>=0) g+=ch; else l-=ch; }
      let ag=g/len, al=l/len; out[len]=al===0?100:100-(100/(1+(ag/al)));
      for(let i=len+1;i<closes.length;i++){ const ch=closes[i]-closes[i-1]; const gg=Math.max(ch,0), ll=Math.max(-ch,0);
        ag=(ag*(len-1)+gg)/len; al=(al*(len-1)+ll)/len; out[i]=al===0?100:100-(100/(1+(ag/al))); } return out; };
    const stochRSI = (closes, rsiLen=14, stochLen=16, kLen=3, dLen=3) => {
      const rr = rsi(closes, rsiLen); const st=Array(closes.length).fill(null);
      let minQ=[],maxQ=[]; const pushMin=i=>{while(minQ.length&&rr[minQ.at(-1)]>=rr[i])minQ.pop();minQ.push(i)};
      const pushMax=i=>{while(maxQ.length&&rr[maxQ.at(-1)]<=rr[i])maxQ.pop();maxQ.push(i)};
      for(let i=0;i<closes.length;i++){ if(rr[i]==null) continue; pushMin(i); pushMax(i);
        const start=i-stochLen+1; while(minQ.length&&minQ[0]<start) minQ.shift(); while(maxQ.length&&maxQ[0]<start) maxQ.shift();
        if(i>=stochLen-1){ const mn=rr[minQ[0]], mx=rr[maxQ[0]]; st[i]=mx===mn?0:((rr[i]-mn)/(mx-mn))*100; } }
      const k=sma(st,kLen), d=sma(k,dLen); return {k,d};
    };
    const bollinger = (closes, len=20, mult=2) => {
      const mid=sma(closes,len), sd=rollingStd(closes,len);
      const upper=mid.map((m,i)=>m==null||sd[i]==null?null:m+mult*sd[i]);
      const lower=mid.map((m,i)=>m==null||sd[i]==null?null:m-mult*sd[i]);
      return {upper,mid,lower};
    };

    // ==== Data ====
    async function fetchKlines(symbol, interval, limit=500){
      const url=`https://api.binance.com/api/v3/klines?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=${limit}`;
      const r=await fetch(url); if(!r.ok) throw new Error('Binance API error');
      const raw=await r.json();
      return raw.map(k=>({ time: Math.floor(k[0]/1000), open:+k[1], high:+k[2], low:+k[3], close:+k[4], volume:+k[5] }));
    }

    // ==== Indicator packs ====
    function indicatorsFor(bars, p){
      const c=bars.map(b=>b.close);
      return {
        bb: bollinger(c, p.bbLen, p.bbMult),
        ma3: sma(c, p.ma3),
        ...stochRSI(c, p.rsiLen, p.stochLen, p.kLen, p.dLen)
      };
    }

    // ==== Strategy core (HTF) + LTF confluence ====
    function withinRange(v, a, b){ const lo=Math.min(a,b), hi=Math.max(a,b); return v>=lo && v<=hi; }

    function checkLtfConfluence(ltfBars, ltfInd, p, side, htfTime){
      if(!ltfBars || !ltfBars.length) return true; // no LTF selected
      // find last LTF bar that closed at/just before HTF close time
      let j = ltfBars.length-1;
      while(j>=0 && ltfBars[j].time > htfTime) j--;
      if(j<0) return false;

      // Look back a few LTF bars for confluence
      const look = Math.max(1, p.ltfLookback);
      let midOK=false, rangeOK=false;

      for(let x=j; x>=0 && x>j-look; x--){
        const close = ltfBars[x].close;
        const mid = ltfInd.bb.mid[x];
        const k = ltfInd.k[x]; const d = ltfInd.d[x];

        if(p.ltfMidBreak){
          midOK = midOK || (side==='SELL' ? close < mid : close > mid);
        } else midOK = true;

        if(p.ltfRangeOn){
          if(side==='SELL'){ // 70–65
            const inBand = (k!=null && withinRange(k,65,70)) || (d!=null && withinRange(d,65,70));
            rangeOK = rangeOK || inBand;
          } else { // BUY 30–50
            const inBand = (k!=null && withinRange(k,30,50)) || (d!=null && withinRange(d,30,50));
            rangeOK = rangeOK || inBand;
          }
        } else rangeOK = true;
      }

      return midOK && rangeOK;
    }

    function generateHTFSignals(htfBars, htfInd, ltfBars, ltfInd, p){
      const { bb, ma3, k, d } = htfInd;
      const highs = htfBars.map(b=>b.high), lows = htfBars.map(b=>b.low);

      const signals=[];
      for(let i=2;i<htfBars.length-1;i++){ // confirmed only (exclude forming)
        if(bb.mid[i]==null || ma3[i]==null || k[i]==null || d[i]==null) continue;

        // Tap upper/lower band in recent bars (wick touch)
        let tappedUpper=false, tappedLower=false;
        for(let t=0; t<=p.tapLookback; t++){
          const idx=i-t; if(idx<0) break;
          tappedUpper = tappedUpper || (bb.upper[idx]!=null && highs[idx] >= bb.upper[idx]);
          tappedLower = tappedLower || (bb.lower[idx]!=null && lows[idx]  <= bb.lower[idx]);
        }

        // 3MA body side
        const closeBelow3 = htfBars[i].close < ma3[i];
        const closeAbove3 = htfBars[i].close > ma3[i];

        // HTF Stoch crosses from OB/OS
        const crossDown = (k[i-1] > d[i-1]) && (k[i] < d[i]);
        const crossUp   = (k[i-1] < d[i-1]) && (k[i] > d[i]);
        const fromOB = (k[i-1]>=p.ob || d[i-1]>=p.ob);
        const fromOS = (k[i-1]<=p.os || d[i-1]<=p.os);
        const crossOKSell = p.requireCross ? (crossDown && fromOB) : fromOB;
        const crossOKBuy  = p.requireCross ? (crossUp && fromOS) : fromOS;

        // LTF confluence (optional)
        const ltfOkSell = checkLtfConfluence(ltfBars, ltfInd, p, 'SELL', htfBars[i].time);
        const ltfOkBuy  = checkLtfConfluence(ltfBars, ltfInd, p, 'BUY',  htfBars[i].time);

        // Final conditions
        const sellCond = tappedUpper && closeBelow3 && crossOKSell && ltfOkSell;
        const buyCond  = tappedLower && closeAbove3 && crossOKBuy  && ltfOkBuy;

        if(sellCond || buyCond){
          const side = sellCond ? 'SELL' : 'BUY';
          const entry = htfBars[i].close;
          const tp = bb.mid[i];
          const sl = sellCond ? Math.max(bb.upper[i], highs[i]) : Math.min(bb.lower[i], lows[i]);
          signals.push({ time: htfBars[i].time, side, price: entry, tp: tp ?? null, sl: sl ?? null, index: i });
        }
      }

      return signals;
    }

    // LIVE intrabar on HTF (uses forming candle) + LTF confluence
    function liveHTFSignal(htfBars, htfInd, ltfBars, ltfInd, p){
      const i = htfBars.length-1; if(i<2) return null;
      const { bb, ma3, k, d } = htfInd; if(!bb.mid[i] || !ma3[i] || k[i]==null || d[i]==null) return null;

      let tappedUpper=false, tappedLower=false;
      for(let t=0; t<=p.tapLookback && i-t>=0; t++){
        const idx=i-t;
        tappedUpper = tappedUpper || (bb.upper[idx]!=null && htfBars[idx].high >= bb.upper[idx]);
        tappedLower = tappedLower || (bb.lower[idx]!=null && htfBars[idx].low  <= bb.lower[idx]);
      }
      const closeBelow3 = htfBars[i].close < ma3[i];
      const closeAbove3 = htfBars[i].close > ma3[i];

      const crossDown = (k[i-1] > d[i-1]) && (k[i] < d[i]);
      const crossUp   = (k[i-1] < d[i-1]) && (k[i] > d[i]);
      const fromOB = (k[i-1]>=p.ob || d[i-1]>=p.ob);
      const fromOS = (k[i-1]<=p.os || d[i-1]<=p.os);
      const crossOKSell = p.requireCross ? (crossDown && fromOB) : fromOB;
      const crossOKBuy  = p.requireCross ? (crossUp && fromOS) : fromOS;

      const ltfOkSell = checkLtfConfluence(ltfBars, ltfInd, p, 'SELL', htfBars[i].time);
      const ltfOkBuy  = checkLtfConfluence(ltfBars, ltfInd, p, 'BUY',  htfBars[i].time);

      const sellCond = tappedUpper && closeBelow3 && crossOKSell && ltfOkSell;
      const buyCond  = tappedLower && closeAbove3 && crossOKBuy  && ltfOkBuy;
      if(!(sellCond||buyCond)) return null;

      const side = sellCond ? 'SELL' : 'BUY';
      const entry = htfBars[i].close;
      const tp = bb.mid[i];
      const sl = sellCond ? Math.max(bb.upper[i], htfBars[i].high) : Math.min(bb.lower[i], htfBars[i].low);
      return { time: htfBars[i].time, side, price: entry, tp: tp ?? null, sl: sl ?? null, provisional: true };
    }

    // ==== Outcomes (on HTF) ====
    function evaluateTrades(bars, signals){
      const trades=[];
      for(const s of signals){
        let exitIdx=null, exitPrice=null, result='OPEN';
        for(let j=s.index+1; j<bars.length; j++){
          const o=bars[j].open, hi=bars[j].high, lo=bars[j].low;
          if(s.side==='BUY'){
            if(o>=s.tp){ exitIdx=j; exitPrice=s.tp; result='WIN'; break; }
            if(o<=s.sl){ exitIdx=j; exitPrice=s.sl; result='LOSS'; break; }
            const hitTP = hi>=s.tp, hitSL = lo<=s.sl;
            if(hitTP && hitSL){
              const tpDist=Math.abs(s.tp-o), slDist=Math.abs(o-s.sl);
              if(tpDist<=slDist){ exitIdx=j; exitPrice=s.tp; result='WIN'; } else { exitIdx=j; exitPrice=s.sl; result='LOSS'; }
              break;
            }
            if(hitTP){ exitIdx=j; exitPrice=s.tp; result='WIN'; break; }
            if(hitSL){ exitIdx=j; exitPrice=s.sl; result='LOSS'; break; }
          } else {
            if(o<=s.tp){ exitIdx=j; exitPrice=s.tp; result='WIN'; break; }
            if(o>=s.sl){ exitIdx=j; exitPrice=s.sl; result='LOSS'; break; }
            const hitTP = lo<=s.tp, hitSL = hi>=s.sl;
            if(hitTP && hitSL){
              const tpDist=Math.abs(o-s.tp), slDist=Math.abs(s.sl-o);
              if(tpDist<=slDist){ exitIdx=j; exitPrice=s.tp; result='WIN'; } else { exitIdx=j; exitPrice=s.sl; result='LOSS'; }
              break;
            }
            if(hitTP){ exitIdx=j; exitPrice=s.tp; result='WIN'; break; }
            if(hitSL){ exitIdx=j; exitPrice=s.sl; result='LOSS'; break; }
          }
        }
        trades.push({
          time: s.time, side: s.side, entry: s.price, tp: s.tp, sl: s.sl,
          exit: exitPrice, result, barsHeld: exitIdx==null? null : (exitIdx - s.index),
          exitTime: exitIdx==null? null : bars[exitIdx].time
        });
      }
      return trades;
    }

    // ==== Chart/UI ====
    let chart, candleSeries, upperSeries, midSeries, lowerSeries, ma3Series;
    let stochChart, kSeries, dSeries, obH, osH;
    let ws=null, pollTimer=null;

    function makeCharts(){
      if(chart) return;
      chart = LightweightCharts.createChart(document.getElementById('chart'), {
        layout:{background:{type:'solid',color:'#111729'}, textColor:'#D8E4FF'},
        grid:{vertLines:{color:'#223250'},horzLines:{color:'#223250'}},
        rightPriceScale:{borderVisible:false}, timeScale:{borderVisible:false,timeVisible:true,secondsVisible:false},
        localization: { locale: navigator.language }
      });
      candleSeries = chart.addCandlestickSeries({upColor:'#26a69a',downColor:'#ef5350',wickUpColor:'#26a69a',wickDownColor:'#ef5350',borderVisible:false});
      upperSeries = chart.addLineSeries({color:'#ff7aa2',lineWidth:2,priceLineVisible:false});
      midSeries   = chart.addLineSeries({color:'#ffd66b',lineWidth:2,priceLineVisible:false});
      lowerSeries = chart.addLineSeries({color:'#7acefa',lineWidth:2,priceLineVisible:false});
      ma3Series   = chart.addLineSeries({color:'#9cf08d',lineWidth:1,priceLineVisible:false});

      stochChart = LightweightCharts.createChart(document.getElementById('stochChart'), {
        layout:{background:{type:'solid',color:'#0f1420'}, textColor:'#cfe2ff'},
        grid:{vertLines:{color:'#1f2a42'}, horzLines:{color:'#1f2a42'}},
        rightPriceScale:{borderVisible:false,scaleMargins:{top:0.12,bottom:0.14}},
        timeScale:{borderVisible:false,timeVisible:true},
        localization: { locale: navigator.language }
      });
      kSeries = stochChart.addLineSeries({color:'#5bc0ff',lineWidth:2});
      dSeries = stochChart.addLineSeries({color:'#ff9f65',lineWidth:2});
    }
    function setOBOS(ob, os, times){
      if(obH) stochChart.removeSeries(obH); if(osH) stochChart.removeSeries(osH);
      obH = stochChart.addLineSeries({color:'rgba(255,206,84,.4)',lineWidth:1});
      osH = stochChart.addLineSeries({color:'rgba(99,206,84,.4)', lineWidth:1});
      obH.setData(times.map(t=>({time:t,value:ob})));
      osH.setData(times.map(t=>({time:t,value:os})));
    }

    function markersCombined(signals, trades){
      const m=[];
      for(const s of signals){
        m.push({ time:s.time, position:s.side==='BUY'?'belowBar':'aboveBar',
          color:s.side==='BUY'?'#21c77a':'#ff5b5b', shape:s.side==='BUY'?'arrowUp':'arrowDown',
          text:`${s.side} ${fmtNum(s.price)}` });
      }
      for(const t of trades){
        if(!t.exit || !t.exitTime) continue;
        m.push({ time:t.exitTime, position:t.side==='BUY'?'aboveBar':'belowBar',
          color:t.result==='WIN'?'#21c77a':'#ff5b5b', shape:t.result==='WIN'?'diamond':'circle',
          text:`${t.result} ${fmtNum(t.exit)}` });
      }
      return m;
    }

    function updateSignalTable(sigs, tf){
      const tbody=document.querySelector('#signalsTable tbody'); tbody.innerHTML='';
      const todayOnly=document.getElementById('todayOnly').checked;
      const sod=startOfTodaySec();
      const list = todayOnly ? sigs.filter(s=>s.time>=sod) : sigs;
      list.slice(-20).reverse().forEach(s=>{
        const tr=document.createElement('tr');
        tr.innerHTML=`<td>${fmtTs(s.time)}</td>
                      <td style="color:${s.side==='BUY'?'#21c77a':'#ff6b6b'}">${s.side}</td>
                      <td>${fmtNum(s.price)}</td>
                      <td>${s.tp?fmtNum(s.tp):'—'}</td>
                      <td>${s.sl?fmtNum(s.sl):'—'}</td>
                      <td>${tf}</td>`;
        tbody.appendChild(tr);
      });
    }

    function updateTradesUI(trades){
      const closed = trades.filter(t => t.result==='WIN' || t.result==='LOSS');
      const wins = closed.filter(t => t.result==='WIN').length;
      const losses = closed.filter(t => t.result==='LOSS').length;
      const wr = (wins + losses) ? (wins/(wins+losses)*100).toFixed(1)+'%' : '—';
      document.getElementById('mTotal').textContent = trades.length;
      document.getElementById('mWins').textContent = wins;
      document.getElementById('mLosses').textContent = losses;
      document.getElementById('mWR').textContent = wr;

      const tbody=document.querySelector('#tradesTable tbody'); tbody.innerHTML='';
      trades.slice(-20).reverse().forEach(t=>{
        const tag = t.result==='WIN' ? 'win' : t.result==='LOSS' ? 'loss' : 'open';
        const tr=document.createElement('tr');
        tr.innerHTML=`<td>${fmtTs(t.time)}</td>
                      <td style="color:${t.side==='BUY'?'#21c77a':'#ff6b6b'}">${t.side}</td>
                      <td>${fmtNum(t.entry)}</td>
                      <td>${fmtNum(t.tp)}</td>
                      <td>${fmtNum(t.sl)}</td>
                      <td>${t.exit?fmtTs(t.exitTime)+' @ '+fmtNum(t.exit):'—'}</td>
                      <td><span class="tag ${tag}">${t.result}</span></td>
                      <td>${t.barsHeld==null?'—':t.barsHeld}</td>`;
        tbody.appendChild(tr);
      });
    }

    function paint(htfBars, htfInd, signals, trades, tf){
      const times=htfBars.map(b=>b.time);
      candleSeries.setData(htfBars);
      upperSeries.setData(times.map((t,i)=>({time:t,value:htfInd.bb.upper[i]??null})));
      midSeries.setData(times.map((t,i)=>({time:t,value:htfInd.bb.mid[i]??null})));
      lowerSeries.setData(times.map((t,i)=>({time:t,value:htfInd.bb.lower[i]??null})));
      ma3Series.setData(times.map((t,i)=>({time:t,value:htfInd.ma3[i]??null})));
      kSeries.setData(times.map((t,i)=>({time:t,value:htfInd.k[i]??null})));
      dSeries.setData(times.map((t,i)=>({time:t,value:htfInd.d[i]??null})));
      setOBOS(params.ob, params.os, times);

      candleSeries.setMarkers(markersCombined(signals, trades));
      updateSignalTable(signals, tf);
      updateTradesUI(trades);

      const last=signals.at(-1);
      const sigEl=document.getElementById('sigNow'), noteEl=document.getElementById('sigNote');
      const tpEl=document.getElementById('tpSl'), tpNote=document.getElementById('tpSlNote');
      if(last){
        sigEl.className='value ' + (last.side==='BUY'?'buy':'sell');
        sigEl.textContent = last.side;
        noteEl.textContent = `Confirmed @ ${fmtTs(last.time)} • ${document.getElementById('symbol').value.toUpperCase()} • ${tf}`;
        tpEl.textContent = `TP ${fmtNum(last.tp)} | SL ${fmtNum(last.sl)}`;
        tpNote.textContent = 'TP = mid band (HTF), SL = beyond outer band or prior extreme.';
      } else {
        sigEl.className='value flat'; sigEl.textContent='No confirmed setup';
        noteEl.textContent='Waiting for a valid HTF setup…'; tpEl.textContent='—'; tpNote.textContent='';
      }
    }

    function showLive(live){
      const sigEl=document.getElementById('sigNow'), noteEl=document.getElementById('sigNote');
      if(!live) return;
      sigEl.className='value ' + (live.side==='BUY'?'buy':'sell');
      sigEl.textContent = `LIVE: ${live.side}`;
      noteEl.textContent = `Unconfirmed • ${document.getElementById('symbol').value.toUpperCase()} ${document.getElementById('sigTf').value} • ${fmtTs(live.time)} • Price ${fmtNum(live.price)} • TP ${fmtNum(live.tp)} • SL ${fmtNum(live.sl)}`;
    }

    // ==== App state ====
    let params={}, htfBars=[], ltfBars=[], htfInd=null, ltfInd=null;

    async function runOnce(){
      makeCharts();
      const symbol=document.getElementById('symbol').value.trim().toUpperCase();
      const sigTf=document.getElementById('sigTf').value;
      const ltfSel=document.getElementById('ltf').value;
      const limit=+document.getElementById('limit').value;

      params = {
        bbLen:+document.getElementById('bbLen').value,
        bbMult:+document.getElementById('bbMult').value,
        ma3:+document.getElementById('ma3').value,
        rsiLen:+document.getElementById('rsiLen').value,
        stochLen:+document.getElementById('stochLen').value,
        kLen:+(document.getElementById('kd').value.split(',')[0]||3),
        dLen:+(document.getElementById('kd').value.split(',')[1]||3),
        ob:+document.getElementById('ob').value,
        os:+document.getElementById('os').value,
        tapLookback:+document.getElementById('tapLookback').value,
        requireCross: document.getElementById('requireCross').value==='true',
        ltfMidBreak: document.getElementById('ltfMidBreak').value==='true',
        ltfRangeOn: document.getElementById('ltfRangeOn').value==='true',
        ltfLookback:+document.getElementById('ltfLookback').value,
      };

      // Fetch HTF
      htfBars = await fetchKlines(symbol, sigTf, limit);
      htfInd = indicatorsFor(htfBars, params);

      // Fetch LTF (optional)
      if(ltfSel!=='none'){
        // Load enough LTF bars to cover the same time span plus headroom
        const ltfLimit = Math.min(1500, limit * 60); // rough headroom
        ltfBars = await fetchKlines(symbol, ltfSel, ltfLimit);
        ltfInd = indicatorsFor(ltfBars, { ...params }); // same params on LTF
      } else { ltfBars=[]; ltfInd=null; }

      // Signals (HTF) with LTF confluence
      const signals = generateHTFSignals(htfBars, htfInd, ltfBars, ltfInd, params);
      const trades  = evaluateTrades(htfBars, signals);
      paint(htfBars, htfInd, signals, trades, sigTf);

      // LIVE
      if(document.getElementById('intrabar').checked){
        const live = liveHTFSignal(htfBars, htfInd, ltfBars, ltfInd, params);
        if(live) showLive(live);
      }

      document.getElementById('info').textContent = sigTf.toUpperCase();
      document.getElementById('infoNote').textContent = ltfSel==='none' ? 'No LTF confluence' : `LTF confluence: ${ltfSel} (mid-break ${params.ltfMidBreak?'ON':'OFF'}, range ${params.ltfRangeOn?'ON':'OFF'})`;
    }

    // ==== WebSocket for HTF ====
    function connectWs(){
      try{ if(ws) ws.close(); }catch(e){}
      const symbol=document.getElementById('symbol').value.trim().toUpperCase();
      const sigTf=document.getElementById('sigTf').value;
      ws = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@kline_${sigTf}`);
      ws.onmessage = (ev)=>{
        const msg=JSON.parse(ev.data); if(!msg || !msg.k) return; const k=msg.k;
        const bar={ time:Math.floor(k.t/1000), open:+k.o, high:+k.h, low:+k.l, close:+k.c };
        if(!htfBars.length){ candleSeries.update(bar); return; }
        const last=htfBars[htfBars.length-1];
        if(bar.time===last.time){ htfBars[htfBars.length-1]=bar; } else { htfBars.push(bar); }

        // Recompute HTF indicators incrementally
        htfInd = indicatorsFor(htfBars, params);
        candleSeries.update(bar);
        if(document.getElementById('intrabar').checked){
          const live = liveHTFSignal(htfBars, htfInd, ltfBars, ltfInd, params);
          if(live) showLive(live);
        }
        // On HTF candle close, recompute confirmed signals/outcomes
        if(k.x) runOnce().catch(console.error);
      };
      ws.onclose = ()=> setTimeout(connectWs, 3500);
      ws.onerror = ()=> { try{ws.close();}catch(e){} };
    }

    // Poll fallback
    function restartTimer(){
      clearInterval(pollTimer);
      const sec=+document.getElementById('refreshSec').value;
      if(sec>0) pollTimer=setInterval(()=>runOnce().catch(console.error), sec*1000);
    }
    function reconfigure(){ connectWs(); runOnce().catch(console.error); }

    // CSV (signals)
    function downloadCSV(){
      const rows=[...document.querySelectorAll('#signalsTable tbody tr')].map(tr=>[...tr.children].map(td=>td.textContent));
      if(!rows.length) return;
      const header=['Time','Side','Price','TP','SL','TF'];
      const csv=[header,...rows.reverse()].map(r=>r.join(',')).join('\n');
      const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download='signals.csv'; a.click(); URL.revokeObjectURL(url);
    }

    // Events
    document.getElementById('run').addEventListener('click', ()=>runOnce().catch(console.error));
    document.getElementById('csv').addEventListener('click', downloadCSV);
    ['bbLen','bbMult','ma3','rsiLen','stochLen','kd','ob','os','tapLookback','requireCross','ltfMidBreak','ltfRangeOn','ltfLookback','limit','todayOnly','intrabar']
      .forEach(id=>document.getElementById(id).addEventListener('change', ()=>runOnce().catch(console.error)));
    document.getElementById('sigTf').addEventListener('change', reconfigure);
    document.getElementById('symbol').addEventListener('change', reconfigure);
    document.getElementById('symbol').addEventListener('keyup', e=>{ if(e.key==='Enter') reconfigure(); });
    document.getElementById('ltf').addEventListener('change', ()=>runOnce().catch(console.error));
    document.getElementById('refreshSec').addEventListener('change', restartTimer);

    // Init
    (async()=>{ makeCharts(); await runOnce(); restartTimer(); connectWs(); })().catch(console.error);
  </script>
</body>
</html>
