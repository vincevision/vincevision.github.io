<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bollinger + Stoch Structural Signals (Deriv) — Auto Market Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0e1220;
      --panel: #141a2a;
      --text: #e7ecf4;
      --muted: #94a3b8;
      --accent: #00d1b2;
      --accent-2: #7c5cff;
      --danger: #ef4444;
      --success: #10b981;
      --warning: #f59e0b;
      --border: #273046;
      --chip: #1f2a44;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: linear-gradient(180deg, #0b1020 0%, #0c1324 100%);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    header {
      padding: 20px 16px;
      border-bottom: 1px solid var(--border);
      display: flex; flex-direction: column; gap: 10px;
      background: radial-gradient(1200px 400px at 10% -20%, rgba(124,92,255,.15), transparent 60%),
                  radial-gradient(1200px 400px at 90% -30%, rgba(0,209,178,.15), transparent 60%);
    }
    header h1 { margin: 0; font-size: 22px; font-weight: 700; letter-spacing: 0.3px; }
    header .sub { color: var(--muted); font-size: 13px; line-height: 1.4; }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 16px; }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset, 0 10px 30px rgba(0,0,0,0.2);
    }
    .controls { display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; align-items: end; }
    .controls .field { grid-column: span 3; display: flex; flex-direction: column; gap: 6px; }
    .controls .field.small { grid-column: span 2; }
    .controls .field.wide { grid-column: span 6; }
    .controls label { font-size: 12px; color: var(--muted); }
    select, input[type="number"], input[type="text"] {
      background: #0f1423; color: var(--text); border: 1px solid var(--border);
      border-radius: 8px; padding: 10px 12px; outline: none;
    }
    button {
      background: linear-gradient(135deg, var(--accent), #00b8b2);
      border: none; color: #051220; font-weight: 700; padding: 12px 14px;
      border-radius: 10px; cursor: pointer; box-shadow: 0 8px 20px rgba(0,209,178,0.25);
      transition: transform .08s ease;
    }
    button:hover { transform: translateY(-1px); }
    button.secondary { background: #1e283d; color: var(--text); box-shadow: none; border: 1px solid var(--border); }
    .inline { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .chips { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 6px; }
    .chip {
      background: var(--chip); color: var(--muted); font-size: 12px;
      padding: 6px 8px; border: 1px solid var(--border); border-radius: 999px;
    }
    .market-filters { display: flex; gap: 8px; flex-wrap: wrap; }
    .market-filters label {
      display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px;
      border-radius: 999px; border: 1px solid var(--border); background: #0f1423; color: var(--muted);
      cursor: pointer; user-select: none;
    }
    .market-filters input { transform: scale(1.1); }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { border-bottom: 1px solid var(--border); padding: 12px 8px; vertical-align: middle; }
    th { text-align: left; color: var(--muted); font-size: 12px; text-transform: uppercase; letter-spacing: .6px; }
    tr:hover { background: #0f1423; }
    .badge {
      padding: 4px 8px; border-radius: 999px; font-weight: 700; font-size: 11px;
      display: inline-flex; align-items: center; gap: 6px;
    }
    .long { background: rgba(16,185,129,.15); color: var(--success); border: 1px solid rgba(16,185,129,.35); }
    .short { background: rgba(239,68,68,.15); color: var(--danger); border: 1px solid rgba(239,68,68,.35); }
    .muted { color: var(--muted); }
    .status-ok { color: var(--success); }
    .status-warn { color: var(--warning); }
    .status-bad { color: var(--danger); }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .note { color: var(--muted); font-size: 12px; }
    .progress {
      width: 100%; height: 8px; background: #0f1423; border-radius: 6px; overflow: hidden;
      border: 1px solid var(--border);
    }
    .progress > span { display: block; height: 100%; background: linear-gradient(90deg, var(--accent-2), var(--accent)); }
    .footnote { color: var(--muted); font-size: 12px; margin-top: 10px; }
    @media (max-width: 900px) {
      .controls .field { grid-column: span 6; }
      .controls .field.small { grid-column: span 6; }
      .controls .field.wide { grid-column: span 6; }
    }
    @media (max-width: 600px) {
      .controls { grid-template-columns: repeat(6, 1fr); }
      .controls .field, .controls .field.small, .controls .field.wide { grid-column: span 6; }
      header h1 { font-size: 18px; }
    }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>Bollinger + Stoch Structural Signals (Deriv) — Auto Market Scanner</h1>
    <div class="sub">
      HTF Stochastic overbought/oversold sets the bias. LTF entry = break of last swing (high for longs when HTF is oversold, low for shorts when HTF is overbought).
      TP = HTF Bollinger middle band. SL = ATR × mult or BB outer band ± buffer. Scanner can auto-pick valid markets. App ID: 1089.
    </div>
  </div>
</header>

<main class="wrap">
  <section class="panel">
    <div class="controls">
      <div class="field small">
        <label>Endpoint</label>
        <select id="endpointSelect">
          <option value="wss://ws.derivws.com/websockets/v3">Deriv (ws.derivws.com)</option>
          <option value="wss://ws.binaryws.com/websockets/v3">Binary (ws.binaryws.com)</option>
        </select>
      </div>
      <div class="field small">
        <label>App ID</label>
        <input id="appId" type="number" value="1089" min="1" />
      </div>
      <div class="field">
        <label>&nbsp;</label>
        <div class="inline">
          <button id="reconnectBtn" class="secondary">Reconnect</button>
          <span class="note" id="status">Status: initializing…</span>
        </div>
      </div>

      <div class="field">
        <label>Symbol</label>
        <select id="symbolSelect"></select>
        <div class="chips" id="symbolMeta"></div>
      </div>
      <div class="field small">
        <label>Manual symbol (override)</label>
        <div class="inline">
          <input id="manualSymbol" type="text" placeholder="e.g., frxEURUSD or R_75" />
          <button id="useManualBtn" class="secondary">Use</button>
        </div>
      </div>

      <div class="field small">
        <label>HTF</label>
        <select id="htfSelect">
          <option value="900">15m</option>
          <option value="1800">30m</option>
          <option value="3600" selected>1h</option>
          <option value="7200">2h</option>
          <option value="14400">4h</option>
          <option value="43200">12h</option>
          <option value="86400">1d</option>
        </select>
      </div>
      <div class="field small">
        <label>LTF</label>
        <select id="ltfSelect">
          <option value="60">1m</option>
          <option value="180">3m</option>
          <option value="300" selected>5m</option>
          <option value="900">15m</option>
          <option value="1800">30m</option>
        </select>
      </div>

      <div class="field small">
        <label>BB period</label>
        <input id="bbPeriod" type="number" value="20" min="5" max="200" />
      </div>
      <div class="field small">
        <label>BB StdDev</label>
        <input id="bbStd" type="number" value="2" step="0.1" min="0.5" max="4" />
      </div>
      <div class="field small">
        <label>Stoch K/D/Smooth</label>
        <div class="inline">
          <input id="stochK" type="number" value="14" min="3" max="100" style="width:70px;" />
          <input id="stochD" type="number" value="3" min="1" max="10" style="width:70px;" />
          <input id="stochSmooth" type="number" value="3" min="1" max="10" style="width:70px;" />
        </div>
      </div>
      <div class="field small">
        <label>OB/OS thresholds</label>
        <div class="inline">
          <input id="stochOB" type="number" value="84" min="50" max="100" style="width:90px;" />
          <input id="stochOS" type="number" value="16" min="0" max="50" style="width:90px;" />
        </div>
      </div>

      <div class="field small">
        <label>BOS lookback (bars)</label>
        <input id="bosLookback" type="number" value="25" min="5" max="200" />
      </div>

      <div class="field small">
        <label>SL method</label>
        <select id="slMethod">
          <option value="atr" selected>ATR × Mult</option>
          <option value="bb">BB outer band ± buffer</option>
        </select>
      </div>
      <div class="field small">
        <label>ATR SL mult</label>
        <input id="atrSL" type="number" value="1.0" step="0.1" min="0.1" max="5" />
      </div>
      <div class="field small">
        <label>BB buffer (%)</label>
        <input id="bbBuffer" type="number" value="10" step="1" min="0" max="50" />
      </div>

      <div class="field small">
        <label>Auto update (single symbol)</label>
        <div class="inline">
          <input id="refreshSec" type="number" value="30" min="5" max="600" style="width:120px;">
          <button id="toggleAuto" class="secondary">Start Auto</button>
        </div>
      </div>

      <div class="field wide">
        <label>Market filters (scanner)</label>
        <div class="market-filters" id="marketFilters"></div>
        <div class="inline" style="margin-top:6px;">
          <button id="selectAllMarkets" class="secondary" title="Select all">All</button>
          <button id="selectNoMarkets" class="secondary" title="Select none">None</button>
          <span class="note" id="scanInfo">Scanner idle.</span>
        </div>
      </div>

      <div class="field small">
        <label>Scan step (sec)</label>
        <input id="scanSec" type="number" value="10" min="3" max="300">
      </div>
      <div class="field small">
        <label>Min confidence</label>
        <input id="minConf" type="number" value="60" min="0" max="100">
      </div>
      <div class="field small">
        <label>Max rows</label>
        <input id="maxRows" type="number" value="100" min="10" max="500">
      </div>
      <div class="field">
        <label>Scanner</label>
        <div class="inline">
          <button id="toggleScan">Start Auto Scan</button>
          <button id="clearSignals" class="secondary">Clear Signals</button>
        </div>
      </div>

      <div class="field">
        <label>&nbsp;</label>
        <div class="inline">
          <button id="analyzeBtn">Analyze Now</button>
          <button id="findFirstBtn" class="secondary">Find First Valid (scan)</button>
          <button id="backtestBtn" class="secondary">Backtest (last 20 HTF)</button>
        </div>
      </div>
    </div>

    <div class="chips" style="margin-top:10px">
      <span class="chip">HTF: Stoch(K/D/S) OB/OS (default 14/3/3; OB 84 / OS 16)</span>
      <span class="chip">LTF: Entry requires BOS of the last swing (no body-closure filter)</span>
      <span class="chip">TP: HTF Bollinger middle band</span>
      <span class="chip">SL: ATR × mult or BB outer band ± buffer</span>
    </div>
  </section>

  <section class="panel">
    <div class="inline" style="justify-content: space-between; align-items:center; margin-bottom:6px;">
      <h3 style="margin:0; font-size:16px;">Live Signals (Multi-market)</h3>
      <div class="note" id="connNote"></div>
    </div>
    <table id="signalsTable">
      <thead>
        <tr>
          <th>Time</th>
          <th>Symbol</th>
          <th>HTF/LTF</th>
          <th>Bias</th>
          <th>HTF BB Mid</th>
          <th>LTF BB Mid</th>
          <th>Entry</th>
          <th>SL</th>
          <th>TP</th>
          <th>R:R</th>
          <th>Conf</th>
          <th>Note</th>
        </tr>
      </thead>
      <tbody id="signalsBody">
        <tr><td colspan="12" class="muted">No signals yet. Click Analyze, Find First Valid, or Start Auto Scan.</td></tr>
      </tbody>
    </table>
    <div class="footnote">
      Scanner rotates through selected markets/symbols and adds only signals that meet the min confidence. It also switches the visible symbol automatically as it scans.
    </div>
  </section>

  <section class="panel">
    <div class="grid-2">
      <div>
        <h3 style="margin:0; font-size:16px;">Backtest Snapshot</h3>
        <div class="note">Prototype backtest on last 20 HTF periods. Entry = first LTF BOS of last swing inside each HTF candle.</div>
      </div>
      <div>
        <div class="note" id="btSummary">No backtest yet.</div>
        <div class="progress" style="margin-top:8px;"><span id="btBar" style="width:0%"></span></div>
      </div>
    </div>
    <div style="margin-top:12px; overflow:auto;">
      <table id="btTable">
        <thead>
          <tr>
            <th>#</th>
            <th>HTF Time</th>
            <th>Bias</th>
            <th>Entry</th>
            <th>SL</th>
            <th>TP</th>
            <th>Outcome</th>
            <th>R</th>
          </tr>
        </thead>
        <tbody id="btBody">
          <tr><td colspan="8" class="muted">Run a backtest to populate.</td></tr>
        </tbody>
      </table>
    </div>
  </section>

  <section class="panel">
    <div class="note">
      Educational tool. Markets change — no fixed win rate is guaranteed. Always validate on your own charts and manage risk.
    </div>
  </section>
</main>

<script>
/** Config */
let APP_ID = 1089;
let ENDPOINT = 'wss://ws.derivws.com/websockets/v3';

/** Status helpers */
function setStatus(msg) {
  document.getElementById('status').textContent = 'Status: ' + msg;
  document.getElementById('connNote').textContent = msg;
}
function fmtTime(epoch) {
  try { return new Date(epoch*1000).toISOString().replace('T',' ').slice(0,19); }
  catch(_) { return String(epoch); }
}
function pipToDecimals(pip) {
  if (!pip) return 4;
  const s = String(pip);
  if (s.includes('e-')) return Math.abs(Number(s.split('e-')[1] || 0));
  if (!s.includes('.')) return 0;
  return s.split('.')[1].length;
}
function formatPrice(v, pip) {
  if (v === null || v === undefined || !isFinite(v)) return '-';
  const decimals = pipToDecimals(pip || 0.0001);
  return Number(v).toFixed(decimals);
}
function secToTfLabel(s) {
  const map = {60:'1m',120:'2m',180:'3m',300:'5m',600:'10m',900:'15m',1800:'30m',3600:'1h',7200:'2h',14400:'4h',28800:'8h',43200:'12h',86400:'1d'};
  return map[s] || (s + 's');
}

/** Math & indicators */
function sma(values, period) {
  const out = Array(values.length).fill(null);
  if (period <= 0) return out;
  let sum = 0;
  for (let i=0;i<values.length;i++) {
    const v = Number(values[i]);
    sum += v;
    if (i >= period) sum -= Number(values[i-period]);
    if (i >= period-1) out[i] = sum / period;
  }
  return out;
}
function stddev(values, period) {
  const out = Array(values.length).fill(null);
  if (period <= 0) return out;
  for (let i=0;i<values.length;i++) {
    if (i < period-1) continue;
    const slice = values.slice(i-period+1, i+1).map(Number);
    const mean = slice.reduce((a,b)=>a+b,0)/period;
    const variance = slice.reduce((a,b)=>a+(b-mean)*(b-mean),0)/period;
    out[i] = Math.sqrt(variance);
  }
  return out;
}
function bollinger(closes, period=20, stdev=2) {
  const basis = sma(closes, period);
  const dev = stddev(closes, period);
  const upper = basis.map((b,i)=> b===null || dev[i]===null ? null : b + stdev * dev[i]);
  const lower = basis.map((b,i)=> b===null || dev[i]===null ? null : b - stdev * dev[i]);
  return {basis, upper, lower, dev};
}
function atr(c, period=14) {
  const tr=[];
  for (let i=0;i<c.length;i++){
    if (i===0) tr.push(Math.abs(c[0].high - c[0].low));
    else { const h=c[i].high, l=c[i].low, pc=c[i-1].close; tr.push(Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc))); }
  }
  const out=Array(c.length).fill(null);
  if (c.length<=period) return out;
  let a=tr.slice(1,period+1).reduce((x,y)=>x+y,0)/period; out[period]=a;
  for (let i=period+1;i<tr.length;i++){ a=(a*(period-1)+tr[i])/period; out[i]=a; }
  return out;
}
function stoch(candles, kPeriod=14, dPeriod=3, smoothK=3) {
  const len = candles.length;
  const kRaw = Array(len).fill(null);
  const k = Array(len).fill(null);
  const d = Array(len).fill(null);
  const highs = candles.map(c=>c.high);
  const lows = candles.map(c=>c.low);
  const closes = candles.map(c=>c.close);
  for (let i=0;i<len;i++){
    if (i<kPeriod-1) continue;
    let highest = -Infinity, lowest = Infinity;
    for (let j=i-kPeriod+1;j<=i;j++){
      if (highs[j] > highest) highest = highs[j];
      if (lows[j] < lowest) lowest = lows[j];
    }
    const range = Math.max(1e-12, highest - lowest);
    kRaw[i] = 100 * (closes[i] - lowest) / range;
  }
  const kSmoothed = sma(kRaw.map(v => v===null?0:v), smoothK);
  for (let i=0;i<len;i++) {
    if (kSmoothed[i] !== null && i>= (kPeriod -1)) k[i] = kSmoothed[i];
  }
  const dArr = sma(k.map(v => v===null?0:v), dPeriod);
  for (let i=0;i<len;i++){
    if (dArr[i] !== null && i>= (kPeriod -1 + smoothK -1 + dPeriod -1)) d[i] = dArr[i];
  }
  return {k, d};
}

/** Deriv WS helper */
class DerivWS {
  constructor(getUrlFn) {
    this.getUrlFn = getUrlFn;
    this.ws = null;
    this.queue = [];
    this.pending = new Map();
    this.connected = false;
    this.manualClose = false;
    this._connect();
  }
  _connect() {
    try {
      const url = this.getUrlFn();
      this.ws = new WebSocket(url);
      this.ws.onopen = () => { this.connected = true; setStatus('Connected to ' + url); this._flush(); };
      this.ws.onmessage = (ev) => {
        const data = JSON.parse(ev.data);
        if (data.error) {
          setStatus(`Deriv error: ${data.error.message} [${data.error.code||'ERR'}]`);
          if (data.req_id && this.pending.has(data.req_id)) {
            this.pending.get(data.req_id).reject(data.error);
            this.pending.delete(data.req_id);
          }
          return;
        }
        if (data.req_id && this.pending.has(data.req_id)) {
          this.pending.get(data.req_id).resolve(data);
          this.pending.delete(data.req_id);
        }
      };
      this.ws.onclose = () => {
        this.connected = false;
        if (!this.manualClose) { setStatus('Disconnected. Reconnecting…'); setTimeout(() => this._connect(), 1200); }
        else { setStatus('Disconnected.'); }
      };
      this.ws.onerror = (e) => { console.error('WS error:', e); setStatus('WebSocket error. Check network / endpoint / app_id.'); };
    } catch (e) { console.error('Connect error:', e); setStatus('Failed to open WebSocket: ' + (e.message || e)); }
  }
  _flush() {
    while (this.queue.length && this.connected) {
      const {payload, resolve, reject, req_id} = this.queue.shift();
      this.pending.set(req_id, {resolve, reject});
      this.ws.send(JSON.stringify(payload));
    }
  }
  send(payload) {
    return new Promise((resolve, reject) => {
      const req_id = Math.floor(Math.random() * 1e9);
      payload.req_id = req_id;
      if (!this.connected) { this.queue.push({payload, resolve, reject, req_id}); }
      else { this.pending.set(req_id, {resolve, reject}); this.ws.send(JSON.stringify(payload)); }
    });
  }
  close() { this.manualClose = true; try { this.ws && this.ws.close(); } catch(_) {} }
}

/** Globals */
let api = null;
let SYMBOLS = [];
let MARKETS = [];
let CURRENT_SYMBOL = null;
let CURRENT_PIP = 0.0001;

let AUTO_TIMER = null;
let SCAN_ACTIVE = false;
let SCAN_TIMER = null;
let SCAN_BUSY = false;
let SCAN_LIST = [];
let SCAN_INDEX = 0;
const SIGNALS_SEEN = new Set();

/** Swing helper (hardened) */
function findLastSwing(candles, type='high', lookback=25, left=2, right=2) {
  if (!candles || candles.length < left + right + 1) return null;

  const len = candles.length;
  const effectiveLB = Math.max(lookback, left + right + 1);
  const start = Math.max(left, len - effectiveLB - right);
  const end = len - 1 - right;

  let lastIdx = null;
  for (let i = start; i <= end; i++) {
    let isPivot = true;

    for (let l = 1; l <= left; l++) {
      const cur = candles[i];
      const before = candles[i - l];
      if (!cur || !before) { isPivot = false; break; }
      if (type === 'high') {
        if (cur.high < before.high) { isPivot = false; break; }
      } else {
        if (cur.low > before.low) { isPivot = false; break; }
      }
    }

    for (let r = 1; r <= right && isPivot; r++) {
      const cur = candles[i];
      const after = candles[i + r];
      if (!cur || !after) { isPivot = false; break; }
      if (type === 'high') {
        if (cur.high < after.high) { isPivot = false; break; }
      } else {
        if (cur.low > after.low) { isPivot = false; break; }
      }
    }

    if (isPivot) lastIdx = i;
  }
  return lastIdx;
}

/** Strategy core: HTF Stoch OB/OS + LTF last swing break; TP = HTF BB mid; SL = ATR or LTF BB outer ± buffer */
function computeSignal({ htf, ltf, params }) {
  if (!htf || !ltf || htf.length < 60 || ltf.length < 60) return null;

  const closesH = htf.map(c=>c.close);
  const closesL = ltf.map(c=>c.close);

  // HTF indicators
  const bbH = bollinger(closesH, params.bbPeriod, params.bbStd);
  const stH = stoch(htf, params.stochK, params.stochD, params.stochSmooth);
  const atrHArr = atr(htf, 14);
  const atrHTF = atrHArr.filter(x=>x!==null).pop();
  const basisH = bbH.basis[bbH.basis.length-1];
  const lastH = htf[htf.length-1];
  const kH = stH.k[stH.k.length-1];

  // OB/OS state
  let state = null; // 'overbought' or 'oversold'
  if (kH != null) {
    if (kH >= params.stochOB) state = 'overbought';
    else if (kH <= params.stochOS) state = 'oversold';
  }
  if (!state) return null;

  // LTF context (for SL/confidence; not used for entry trigger)
  const bbL = bollinger(closesL, params.bbPeriod, params.bbStd);
  const basisL = bbL.basis[bbL.basis.length-1];
  const last = ltf[ltf.length-1];
  const price = last.close;
  const atrL = atr(ltf, 14).filter(x=>x!==null).pop();

  // Last swings on LTF
  const swingHighIdx = findLastSwing(ltf, 'high', params.bosLookback, 2, 2);
  const swingLowIdx  = findLastSwing(ltf, 'low',  params.bosLookback, 2, 2);
  const swingHigh = swingHighIdx != null && ltf[swingHighIdx] ? ltf[swingHighIdx].high : null;
  const swingLow  = swingLowIdx  != null && ltf[swingLowIdx]  ? ltf[swingLowIdx].low  : null;

  // BOS condition
  let side = null, note = [], level = null;
  if (state === 'oversold' && swingHigh != null && price > swingHigh) {
    side = 'long';
    level = swingHigh;
    note.push('HTF Stoch oversold', 'BOS last swing high');
  } else if (state === 'overbought' && swingLow != null && price < swingLow) {
    side = 'short';
    level = swingLow;
    note.push('HTF Stoch overbought', 'BOS last swing low');
  } else {
    return null;
  }

  // Entry
  const entry = price;

  // SL
  let sl = null;
  if (params.slMethod === 'atr') {
    const baseATR = atrHTF || atrL || 0;
    if (!baseATR) return null;
    sl = side === 'long' ? entry - params.atrSL * baseATR : entry + params.atrSL * baseATR;
    note.push(`SL=ATR×${params.atrSL}`);
  } else {
    // BB outer band ± buffer (use LTF bands)
    const ub = bbL.upper[bbL.upper.length-1], lb = bbL.lower[bbL.lower.length-1];
    const bw = (ub != null && lb != null) ? (ub - lb) : 0;
    const buf = (params.bbBuffer/100) * bw;
    if (side === 'long') sl = (lb != null ? (lb - buf) : (entry - (atrL || 0)));
    else sl = (ub != null ? (ub + buf) : (entry + (atrL || 0)));
    note.push(`SL=BB outer ±${params.bbBuffer}% BW`);
  }

  // TP = HTF BB middle band
  const tp = basisH;
  if (tp == null || !isFinite(tp)) return null;
  note.push('TP=HTF BB mid');

  // R:R
  const rr = Math.abs((tp - entry) / Math.max(1e-12, (entry - sl)));
  if (!isFinite(rr) || rr <= 0.3) { note.push('Unfavorable RR; skipped'); return null; }

  // Confidence score
  let conf = 50;
  // Strength of HTF Stoch position
  if (state === 'oversold') conf += kH <= (params.stochOS/2) ? 12 : 8;
  if (state === 'overbought') conf += kH >= ((100 + params.stochOB)/2) ? 12 : 8;
  // Distance beyond swing level (stronger BOS)
  const bandL = (bbL.upper[bbL.upper.length-1] != null && bbL.lower[bbL.lower.length-1] != null) ? (bbL.upper[bbL.upper.length-1] - bbL.lower[bbL.lower.length-1]) : null;
  if (level != null && bandL) {
    const beyond = side === 'long' ? Math.max(0, entry - level) : Math.max(0, level - entry);
    const ratio = beyond / bandL;
    conf += ratio > 0.5 ? 10 : 6;
  } else {
    conf += 6;
  }
  // Distance from HTF mid (more mean reversion potential)
  if (basisH != null && lastH) {
    const distMid = Math.abs(lastH.close - basisH);
    const bandH = (bbH.upper[bbH.upper.length-1] != null && bbH.lower[bbH.lower.length-1] != null) ? (bbH.upper[bbH.upper.length-1] - bbH.lower[bbH.lower.length-1]) : null;
    if (bandH) conf += (distMid / bandH) > 0.5 ? 6 : 3;
  }
  // Volatility penalty (ATR vs LTF band width)
  if (bandL && atrL) {
    const volRatio = atrL / bandL;
    if (volRatio > 1.0) conf -= 8;
    else if (volRatio > 0.7) conf -= 4;
  }
  conf = Math.max(0, Math.min(100, conf));

  return {
    time: last.epoch,
    side,
    entry,
    sl,
    tp,
    rr,
    confidence: conf,
    notes: note.filter(Boolean).join(' · '),
    htfMid: basisH || null,
    ltfMid: basisL || null
  };
}

/** Backtest: first LTF BOS of last swing within each HTF bar; TP = HTF BB mid */
function backtest({ htf, ltf, params, N=20 }) {
  const results = [];
  if (!htf || !ltf || htf.length < N + 40 || ltf.length < 200) return results;

  const atrHTFAll = atr(htf, 14);
  const closesH = htf.map(c=>c.close);
  const closesL = ltf.map(c=>c.close);

  const bbHAll = bollinger(closesH, params.bbPeriod, params.bbStd);
  const bbLAll = bollinger(closesL, params.bbPeriod, params.bbStd);
  const stHAll = stoch(htf, params.stochK, params.stochD, params.stochSmooth);
  const atrLAll = atr(ltf, 14);

  function ltfRangeIndices(startEpoch, endEpoch) {
    let s = ltf.findIndex(c => c.epoch >= startEpoch); if (s===-1) s=0;
    let e = ltf.findIndex(c => c.epoch >= endEpoch); if (e===-1) e=ltf.length;
    return [s, e];
  }

  const startIdx = Math.max(2, htf.length - (N + 2));
  for (let i = startIdx; i < htf.length - 1; i++) {
    const hPrev = htf[i-1], hCurr = htf[i];
    if (!hPrev || !hCurr) continue;

    const kH = stHAll.k[i];
    const ob = kH != null && kH >= params.stochOB;
    const os = kH != null && kH <= params.stochOS;
    if (!ob && !os) continue;

    const [lStart, lEnd] = ltfRangeIndices(hPrev.epoch, hCurr.epoch);
    if (lEnd - lStart < 10) continue;

    let opened = false, side = null, entry = null, sl = null, tp = null;

    const atrHVal = atrHTFAll[i] || atrHTFAll.filter(x=>x!=null).slice(-1)[0] || 0;
    const tpMid = bbHAll.basis[i]; // HTF mid for this bar
    if (tpMid == null) continue;

    for (let j = Math.max(lStart + 5, 5); j < lEnd; j++) {
      if (!ltf[j]) continue;
      const last = ltf[j];
      const price = last.close;

      // Determine swings only on the slice up to j
      const sub = ltf.slice(lStart, j + 1);
      const shIdx = findLastSwing(sub, 'high', params.bosLookback, 2, 2);
      const slIdx = findLastSwing(sub, 'low',  params.bosLookback, 2, 2);
      const shVal = (shIdx != null && sub[shIdx]) ? sub[shIdx].high : null;
      const slVal = (slIdx != null && sub[slIdx]) ? sub[slIdx].low  : null;

      // BOS relative to last swing
      const bosLong  = os && shVal != null && price > shVal;
      const bosShort = ob && slVal != null && price < slVal;

      if (!opened) {
        if (bosLong) {
          side = 'long'; entry = price;

          if (params.slMethod === 'atr') {
            const a = atrHVal || atrLAll[j] || 0;
            sl = entry - a * params.atrSL;
          } else {
            const ub = bbLAll.upper[j], lb = bbLAll.lower[j];
            const bw = (ub != null && lb != null) ? (ub - lb) : 0;
            const buf = (params.bbBuffer/100) * bw;
            sl = (lb != null) ? (lb - buf) : (entry - (atrLAll[j] || 0));
          }

          tp = tpMid;
          opened = true;

        } else if (bosShort) {
          side = 'short'; entry = price;

          if (params.slMethod === 'atr') {
            const a = atrHVal || atrLAll[j] || 0;
            sl = entry + a * params.atrSL;
          } else {
            const ub = bbLAll.upper[j], lb = bbLAll.lower[j];
            const bw = (ub != null && lb != null) ? (ub - lb) : 0;
            const buf = (params.bbBuffer/100) * bw;
            sl = (ub != null) ? (ub + buf) : (entry + (atrLAll[j] || 0));
          }

          tp = tpMid;
          opened = true;
        }
      } else {
        // Manage inside HTF window
        const hi = last.high, lo = last.low;
        if (side === 'long') {
          if (lo <= sl) { results.push({ idx:i, time:hCurr.epoch, side, entry, sl, tp, outcome:'SL', R:-1 }); break; }
          if (hi >= tp) { const R = (tp - entry) / Math.max(1e-12, entry - sl); results.push({ idx:i, time:hCurr.epoch, side, entry, sl, tp, outcome:'TP', R }); break; }
        } else {
          if (hi >= sl) { results.push({ idx:i, time:hCurr.epoch, side, entry, sl, tp, outcome:'SL', R:-1 }); break; }
          if (lo <= tp) { const R = (entry - tp) / Math.max(1e-12, sl - entry); results.push({ idx:i, time:hCurr.epoch, side, entry, sl, tp, outcome:'TP', R }); break; }
        }

        if (j === lEnd - 1) {
          results.push({ idx:i, time:hCurr.epoch, side:side||'none', entry, sl, tp, outcome:'NoFill', R:0 });
        }
      }
    }
  }

  return results.slice(-N);
}

/** API wrappers */
async function getActiveSymbols() {
  const attempts = [
    { active_symbols: 'brief', product_type: 'financial' },
    { active_symbols: 'brief', product_type: 'derived' },
    { active_symbols: 'brief', product_type: 'basic' },
    { active_symbols: 'brief' }
  ];
  const combined = [];
  const seen = new Set();
  let lastError = null;

  for (const p of attempts) {
    try {
      const res = await api.send(p);
      const list = Array.isArray(res.active_symbols) ? res.active_symbols : [];
      for (const s of list) {
        if (!seen.has(s.symbol)) { seen.add(s.symbol); combined.push(s); }
      }
    } catch (err) { lastError = err; console.warn('active_symbols attempt failed:', err); }
  }
  if (!combined.length && lastError) {
    setStatus(`active_symbols failed: ${lastError.message} [${lastError.code||'ERR'}]`);
  }
  return combined.sort((a,b)=>a.display_name.localeCompare(b.display_name));
}
async function getCandles(symbol, granularity, count=500) {
  if (!symbol) throw new Error('Symbol not selected');
  const res = await api.send({
    ticks_history: symbol,
    adjust_start_time: 1,
    style: 'candles',
    end: 'latest',
    count: Math.min(Math.max(count, 50), 5000),
    granularity
  });
  if (res && res.candles) return res.candles;
  throw new Error('No candles returned');
}

/** UI + Scanner */
function createAPI() {
  if (api) { try { api.close(); } catch(_) {} }
  APP_ID = parseInt(document.getElementById('appId').value) || 1089;
  ENDPOINT = document.getElementById('endpointSelect').value;
  api = new DerivWS(() => `${ENDPOINT}?app_id=${APP_ID}`);
}

async function loadSymbols() {
  setStatus('Loading symbols…');
  SYMBOLS = await getActiveSymbols();
  const sel = document.getElementById('symbolSelect');
  sel.innerHTML = '';
  if (!SYMBOLS.length) {
    setStatus('Could not load symbols. Check endpoint/app_id or use manual symbol.');
    buildMarketFilters();
    return;
  }
  for (const s of SYMBOLS) {
    const opt = document.createElement('option');
    opt.value = s.symbol;
    opt.textContent = `${s.display_name} (${s.symbol})`;
    sel.appendChild(opt);
  }
  sel.value = SYMBOLS.find(s => /EURUSD/i.test(s.display_name))?.symbol
           || SYMBOLS.find(s => /Volatility 75/i.test(s.display_name))?.symbol
           || SYMBOLS[0].symbol;
  CURRENT_SYMBOL = sel.value;
  CURRENT_PIP = Number(SYMBOLS.find(x=>x.symbol===CURRENT_SYMBOL)?.pip) || 0.0001;
  updateSymbolMeta();
  buildMarketFilters();
  updateScanList();
  setStatus(`Loaded ${SYMBOLS.length} symbols`);
}

function buildMarketFilters() {
  const byCode = new Map();
  for (const s of SYMBOLS) {
    const code = s.market || s.market_display_name || 'other';
    const name = s.market_display_name || s.market || code;
    if (!byCode.has(code)) byCode.set(code, { code, name, count: 0 });
    byCode.get(code).count += 1;
  }
  MARKETS = Array.from(byCode.values()).sort((a,b)=>a.name.localeCompare(b.name));
  const container = document.getElementById('marketFilters');
  container.innerHTML = '';
  if (!MARKETS.length) {
    const lbl = document.createElement('span');
    lbl.className = 'note';
    lbl.textContent = 'No markets available. Use manual symbol.';
    container.appendChild(lbl);
    return;
  }
  for (const m of MARKETS) {
    const id = `mkt_${m.code}`;
    const lab = document.createElement('label');
    lab.setAttribute('for', id);
    lab.innerHTML = `<input type="checkbox" id="${id}" data-market="${m.code}" checked /> ${m.name} (${m.count})`;
    container.appendChild(lab);
  }
  container.addEventListener('change', () => {
    updateScanList();
  });
}

function selectedMarkets() {
  const container = document.getElementById('marketFilters');
  const inputs = container.querySelectorAll('input[type="checkbox"]');
  const out = [];
  inputs.forEach(i => { if (i.checked) out.push(i.getAttribute('data-market')); });
  return out;
}

function updateScanList() {
  const mkts = new Set(selectedMarkets());
  SCAN_LIST = SYMBOLS.filter(s => mkts.size ? mkts.has(s.market || s.market_display_name) : true).map(s => s.symbol);
  SCAN_INDEX = 0;
  document.getElementById('scanInfo').textContent = `Scanner list: ${SCAN_LIST.length} symbols selected.`;
}

function updateSymbolMeta() {
  const code = CURRENT_SYMBOL;
  const s = SYMBOLS.find(x=>x.symbol === code);
  CURRENT_PIP = Number(s?.pip) || CURRENT_PIP || 0.0001;
  const decimals = pipToDecimals(CURRENT_PIP);
  const market = s?.market_display_name || s?.market || '-';
  const submarket = s?.submarket_display_name || s?.submarket || '-';
  const meta = document.getElementById('symbolMeta');
  meta.innerHTML = '';
  [['Market', market], ['Sub', submarket], ['Pip', String(s?.pip || '-')], ['Digits', String(decimals)]].forEach(([k,v])=>{
    const sp = document.createElement('span'); sp.className='chip'; sp.textContent = `${k}: ${v}`; meta.appendChild(sp);
  });
}

function getParams() {
  return {
    htf: Number(document.getElementById('htfSelect').value),
    ltf: Number(document.getElementById('ltfSelect').value),
    bbPeriod: Number(document.getElementById('bbPeriod').value),
    bbStd: Number(document.getElementById('bbStd').value),
    stochK: Number(document.getElementById('stochK').value),
    stochD: Number(document.getElementById('stochD').value),
    stochSmooth: Number(document.getElementById('stochSmooth').value),
    stochOB: Number(document.getElementById('stochOB').value),
    stochOS: Number(document.getElementById('stochOS').value),
    bosLookback: Number(document.getElementById('bosLookback').value),
    slMethod: document.getElementById('slMethod').value,
    atrSL: Number(document.getElementById('atrSL').value),
    bbBuffer: Number(document.getElementById('bbBuffer').value),
  };
}

async function analyzeSymbol(symbol, params) {
  const [htf, ltf] = await Promise.all([
    getCandles(symbol, params.htf, 500),
    getCandles(symbol, params.ltf, 1500),
  ]);
  htf.forEach(c => { c.open=+c.open; c.high=+c.high; c.low=+c.low; c.close=+c.close; c.epoch=+c.epoch; });
  ltf.forEach(c => { c.open=+c.open; c.high=+c.high; c.low=+c.low; c.close=+c.close; c.epoch=+c.epoch; });
  const sig = computeSignal({ htf, ltf, params });
  return { sig, htf, ltf, params };
}

function renderSingleSignal(data) {
  const { sig, params } = data;
  const tbody = document.getElementById('signalsBody');
  tbody.innerHTML = '';
  if (!sig) {
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 12;
    td.className = 'muted';
    td.textContent = 'No signal right now (conditions not met).';
    tr.appendChild(td);
    tbody.appendChild(tr);
    return;
  }
  addSignalRow(sig, CURRENT_SYMBOL, params, true);
}

function addSignalRow(sig, symbol, params, replace=false) {
  if (!sig) return;
  const minConf = Math.max(0, Math.min(100, Number(document.getElementById('minConf').value) || 0));
  if (sig.confidence < minConf) return;

  const key = `${symbol}|${sig.time}|${sig.side}|${params.htf}|${params.ltf}`;
  if (SIGNALS_SEEN.has(key) && !replace) return;
  SIGNALS_SEEN.add(key);

  const tbody = document.getElementById('signalsBody');
  if (replace) tbody.innerHTML = '';

  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td>${fmtTime(sig.time)}</td>
    <td>${symbol}</td>
    <td>${secToTfLabel(params.htf)} / ${secToTfLabel(params.ltf)}</td>
    <td><span class="badge ${sig.side === 'long' ? 'long' : 'short'}">${sig.side.toUpperCase()}</span></td>
    <td>${formatPrice(sig.htfMid||0, CURRENT_PIP)}</td>
    <td>${formatPrice(sig.ltfMid||0, CURRENT_PIP)}</td>
    <td>${formatPrice(sig.entry, CURRENT_PIP)}</td>
    <td>${formatPrice(sig.sl, CURRENT_PIP)}</td>
    <td>${formatPrice(sig.tp, CURRENT_PIP)}</td>
    <td>${sig.rr.toFixed(2)}</td>
    <td>${sig.confidence}%</td>
    <td>${sig.notes}</td>
  `;
  if (tbody.firstChild && !replace) tbody.insertBefore(tr, tbody.firstChild);
  else tbody.appendChild(tr);

  const maxRows = Math.max(10, Math.min(500, Number(document.getElementById('maxRows').value) || 100));
  while (tbody.rows.length > maxRows) {
    const lastRow = tbody.lastElementChild;
    if (lastRow) tbody.removeChild(lastRow);
  }
}

function clearSignals() {
  SIGNALS_SEEN.clear();
  const tbody = document.getElementById('signalsBody');
  tbody.innerHTML = '<tr><td colspan="12" class="muted">Cleared. Waiting for new signals…</td></tr>';
}

/** Event handlers */
async function onAnalyze() {
  try {
    const params = getParams();
    if (params.ltf >= params.htf) { alert('Lower timeframe must be smaller than HTF.'); return; }
    updateScanList();

    if (!CURRENT_SYMBOL && SCAN_LIST.length) {
      CURRENT_SYMBOL = SCAN_LIST[0];
    }
    if (!CURRENT_SYMBOL) { alert('Select or enter a symbol first.'); return; }

    setStatus('Fetching candles…');
    let data = await analyzeSymbol(CURRENT_SYMBOL, params);

    // Auto-pick first valid symbol if current has no signal
    if (!data.sig && SCAN_LIST.length) {
      setStatus('No signal on current symbol. Searching selected markets for first valid signal…');
      for (let i=0;i<SCAN_LIST.length;i++){
        const sym = SCAN_LIST[i];
        if (sym === CURRENT_SYMBOL) continue;
        try {
          const trial = await analyzeSymbol(sym, params);
          if (trial.sig) {
            CURRENT_SYMBOL = sym;
            const sel = document.getElementById('symbolSelect');
            if (sel.querySelector(`option[value="${sym}"]`)) sel.value = sym;
            const sObj = SYMBOLS.find(x=>x.symbol===sym);
            CURRENT_PIP = Number(sObj?.pip) || 0.0001;
            updateSymbolMeta();
            data = trial;
            setStatus(`Found signal on ${sym}`);
            break;
          }
        } catch (e) {/* continue */}
      }
    } else {
      setStatus('Analysis complete');
    }

    renderSingleSignal(data);
  } catch (err) { console.error(err); setStatus('Error: ' + (err.message || 'analysis failed')); }
}

async function onFindFirst() {
  try {
    const params = getParams();
    if (params.ltf >= params.htf) { alert('Lower timeframe must be smaller than HTF.'); return; }
    updateScanList();
    if (!SCAN_LIST.length) { alert('No symbols in scan list. Select markets.'); return; }
    setStatus('Searching for first valid signal across selected markets…');
    let found = false;
    for (let i=0;i<SCAN_LIST.length;i++){
      const sym = SCAN_LIST[i];
      try {
        const data = await analyzeSymbol(sym, params);
        if (data.sig) {
          CURRENT_SYMBOL = sym;
          const sel = document.getElementById('symbolSelect');
          if (sel.querySelector(`option[value="${sym}"]`)) sel.value = sym;
          const sObj = SYMBOLS.find(x=>x.symbol===sym);
          CURRENT_PIP = Number(sObj?.pip) || 0.0001;
          updateSymbolMeta();
          renderSingleSignal(data);
          setStatus(`Found signal on ${sym}`);
          found = true;
          break;
        }
      } catch (e) { /* ignore and continue */ }
    }
    if (!found) {
      setStatus('No valid signal found in current selection.');
      renderSingleSignal({ sig: null, params: getParams() });
    }
  } catch (e) {
    console.error(e); setStatus('Find-first error: ' + (e.message||e));
  }
}

async function onBacktest() {
  try {
    if (!CURRENT_SYMBOL) { alert('Select or enter a symbol first.'); return; }
    const params = getParams();
    if (params.ltf >= params.htf) { alert('Lower timeframe must be smaller than HTF.'); return; }
    setStatus('Fetching candles for backtest…');
    const [htf, ltf] = await Promise.all([
      getCandles(CURRENT_SYMBOL, params.htf, 700),
      getCandles(CURRENT_SYMBOL, params.ltf, 5000),
    ]);
    htf.forEach(c => { c.open=+c.open; c.high=+c.high; c.low=+c.low; c.close=+c.close; c.epoch=+c.epoch; });
    ltf.forEach(c => { c.open=+c.open; c.high=+c.high; c.low=+c.low; c.close=+c.close; c.epoch=+c.epoch; });

    setStatus('Running backtest…');
    const results = backtest({ htf, ltf, params, N: 20 });
    renderBacktest(results);
    setStatus('Backtest complete');
  } catch (err) { console.error(err); setStatus('Backtest error: ' + (err.message || 'failed')); }
}

function renderBacktest(results) {
  const tbody = document.getElementById('btBody');
  tbody.innerHTML = '';
  if (!results.length) {
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 8; td.className = 'muted';
    td.textContent = 'No results. Increase history or adjust timeframes.';
    tr.appendChild(td);
    tbody.appendChild(tr);
    document.getElementById('btSummary').textContent = 'Win rate: —';
    document.getElementById('btBar').style.width = '0%';
    return;
  }
  let wins=0, losses=0, nofills=0, sumR=0;
  results.forEach((r, idx)=>{
    if (r.outcome==='TP') wins++; else if (r.outcome==='SL') losses++; else nofills++;
    sumR += (r.R || 0);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${idx+1}</td>
      <td>${fmtTime(r.time)}</td>
      <td><span class="badge ${r.side === 'long' ? 'long' : 'short'}">${(r.side||'none').toUpperCase()}</span></td>
      <td>${formatPrice(r.entry||0, CURRENT_PIP)}</td>
      <td>${formatPrice(r.sl||0, CURRENT_PIP)}</td>
      <td>${formatPrice(r.tp||0, CURRENT_PIP)}</td>
      <td class="${r.outcome==='TP'?'status-ok':(r.outcome==='SL'?'status-bad':'muted')}">${r.outcome}</td>
      <td>${(r.R!==undefined && isFinite(r.R)) ? r.R.toFixed(2) : '-'}</td>
    `;
    tbody.appendChild(tr);
  });
  const totalTrades = wins + losses;
  const winRate = totalTrades ? (wins / totalTrades * 100) : 0;
  const avgR = totalTrades ? (sumR / totalTrades) : 0;
  document.getElementById('btSummary').textContent =
    `Trades: ${wins+losses} (wins: ${wins}, losses: ${losses}, no-fills: ${nofills}) • Win rate: ${winRate.toFixed(1)}% • Avg R: ${avgR.toFixed(2)}`;
  document.getElementById('btBar').style.width = Math.min(100, Math.max(0, winRate)) + '%';
}

function toggleAutoSingle() {
  const btn = document.getElementById('toggleAuto');
  if (AUTO_TIMER) {
    clearInterval(AUTO_TIMER); AUTO_TIMER=null;
    btn.textContent = 'Start Auto'; btn.classList.add('secondary');
    setStatus('Single-symbol auto update stopped.');
  } else {
    if (SCAN_ACTIVE) { alert('Stop the scanner first.'); return; }
    const sec = Math.max(5, Math.min(600, Number(document.getElementById('refreshSec').value) || 30));
    onAnalyze();
    AUTO_TIMER = setInterval(onAnalyze, sec * 1000);
    btn.textContent = 'Stop Auto'; btn.classList.remove('secondary');
    setStatus('Single-symbol auto update running…');
  }
}

async function scanStep() {
  if (!SCAN_ACTIVE || SCAN_BUSY) return;
  if (!SCAN_LIST.length) { document.getElementById('scanInfo').textContent = 'No symbols to scan. Select markets.'; return; }

  const params = getParams();
  if (params.ltf >= params.htf) { document.getElementById('scanInfo').textContent = 'Fix TFs: LTF must be < HTF.'; return; }

  const sym = SCAN_LIST[SCAN_INDEX % SCAN_LIST.length]; SCAN_INDEX++;
  SCAN_BUSY = true;
  try {
    const sel = document.getElementById('symbolSelect');
    if (sel.querySelector(`option[value="${sym}"]`)) { sel.value = sym; }
    CURRENT_SYMBOL = sym;
    const sObj = SYMBOLS.find(x=>x.symbol===sym);
    CURRENT_PIP = Number(sObj?.pip) || 0.0001;
    updateSymbolMeta();

    document.getElementById('scanInfo').textContent = `Scanning ${sym} (${SCAN_INDEX}/${SCAN_LIST.length}, loops continue)…`;
    const data = await analyzeSymbol(sym, params);
    if (data.sig) addSignalRow(data.sig, sym, params, false);
  } catch (err) {
    console.warn('Scan error for', sym, err);
  } finally {
    SCAN_BUSY = false;
  }
}

function toggleScan() {
  const btn = document.getElementById('toggleScan');
  if (SCAN_ACTIVE) {
    SCAN_ACTIVE = false;
    if (SCAN_TIMER) clearInterval(SCAN_TIMER);
    SCAN_TIMER = null;
    btn.textContent = 'Start Auto Scan';
    btn.classList.add('secondary');
    document.getElementById('scanInfo').textContent = 'Scanner stopped.';
    setStatus('Scanner stopped.');
    return;
  }
  if (AUTO_TIMER) { clearInterval(AUTO_TIMER); AUTO_TIMER=null; document.getElementById('toggleAuto').textContent='Start Auto'; document.getElementById('toggleAuto').classList.add('secondary'); }
  updateScanList();
  if (!SCAN_LIST.length) { alert('No symbols in scan list. Select markets.'); return; }
  const stepSec = Math.max(3, Math.min(300, Number(document.getElementById('scanSec').value) || 10));
  SCAN_ACTIVE = true;
  btn.textContent = 'Stop Auto Scan';
  btn.classList.remove('secondary');
  setStatus('Scanner running…');
  scanStep();
  SCAN_TIMER = setInterval(scanStep, stepSec * 1000);
}

/** Wiring + boot */
function createHandlers() {
  document.getElementById('reconnectBtn').addEventListener('click', boot);
  document.getElementById('analyzeBtn').addEventListener('click', onAnalyze);
  document.getElementById('findFirstBtn').addEventListener('click', onFindFirst);
  document.getElementById('backtestBtn').addEventListener('click', onBacktest);
  document.getElementById('toggleAuto').addEventListener('click', toggleAutoSingle);
  document.getElementById('toggleScan').addEventListener('click', toggleScan);
  document.getElementById('clearSignals').addEventListener('click', clearSignals);

  document.getElementById('symbolSelect').addEventListener('change', function(){
    CURRENT_SYMBOL = this.value;
    const sObj = SYMBOLS.find(x=>x.symbol===CURRENT_SYMBOL);
    CURRENT_PIP = Number(sObj?.pip) || 0.0001;
    updateSymbolMeta();
  });
  document.getElementById('useManualBtn').addEventListener('click', function(){
    const val = (document.getElementById('manualSymbol').value || '').trim();
    if (!val) { alert('Enter a symbol code, e.g., frxEURUSD or R_75'); return; }
    CURRENT_SYMBOL = val;
    setStatus('Using manual symbol: ' + val);
    updateSymbolMeta();
  });

  document.getElementById('selectAllMarkets').addEventListener('click', function(){
    document.querySelectorAll('#marketFilters input[type="checkbox"]').forEach(cb => cb.checked = true);
    updateScanList();
  });
  document.getElementById('selectNoMarkets').addEventListener('click', function(){
    document.querySelectorAll('#marketFilters input[type="checkbox"]').forEach(cb => cb.checked = false);
    updateScanList();
  });
}

function renderBacktest(results) {
  const tbody = document.getElementById('btBody');
  tbody.innerHTML = '';
  if (!results.length) {
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 8; td.className = 'muted';
    td.textContent = 'No results. Increase history or adjust timeframes.';
    tr.appendChild(td);
    tbody.appendChild(tr);
    document.getElementById('btSummary').textContent = 'Win rate: —';
    document.getElementById('btBar').style.width = '0%';
    return;
  }
  let wins=0, losses=0, nofills=0, sumR=0;
  results.forEach((r, idx)=>{
    if (r.outcome==='TP') wins++; else if (r.outcome==='SL') losses++; else nofills++;
    sumR += (r.R || 0);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${idx+1}</td>
      <td>${fmtTime(r.time)}</td>
      <td><span class="badge ${r.side === 'long' ? 'long' : 'short'}">${(r.side||'none').toUpperCase()}</span></td>
      <td>${formatPrice(r.entry||0, CURRENT_PIP)}</td>
      <td>${formatPrice(r.sl||0, CURRENT_PIP)}</td>
      <td>${formatPrice(r.tp||0, CURRENT_PIP)}</td>
      <td class="${r.outcome==='TP'?'status-ok':(r.outcome==='SL'?'status-bad':'muted')}">${r.outcome}</td>
      <td>${(r.R!==undefined && isFinite(r.R)) ? r.R.toFixed(2) : '-'}</td>
    `;
    tbody.appendChild(tr);
  });
  const totalTrades = wins + losses;
  const winRate = totalTrades ? (wins / totalTrades * 100) : 0;
  const avgR = totalTrades ? (sumR / totalTrades) : 0;
  document.getElementById('btSummary').textContent =
    `Trades: ${wins+losses} (wins: ${wins}, losses: ${losses}, no-fills: ${nofills}) • Win rate: ${winRate.toFixed(1)}% • Avg R: ${avgR.toFixed(2)}`;
  document.getElementById('btBar').style.width = Math.min(100, Math.max(0, winRate)) + '%';
}

function createAPIAndLoad() { createAPI(); return loadSymbols(); }

async function boot() {
  try {
    setStatus('Connecting…');
    await createAPIAndLoad();
  } catch (e) {
    console.error(e); setStatus('Boot error: ' + (e.message || e));
  }
}

createHandlers();
boot();
</script>
</body>
</html>
