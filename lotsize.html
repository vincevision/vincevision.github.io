<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Auto Lot Sizer (1% Risk) – Deriv Live</title>
  <style>
    :root{--bg:#0f1221;--panel:#171a2b;--accent:#6c7bff;--accent2:#30dba3;--text:#e7ebff;--muted:#9aa3c7;--warn:#ffb020;--danger:#ff6b6b;--border:#23263d;--radius:14px;--shadow:0 10px 24px rgba(0,0,0,.35)}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;background:radial-gradient(1200px 600px at 10% -10%,#1b1f3b 0%,#0f1221 40%),var(--bg);color:var(--text);line-height:1.45}
    header{padding:26px 18px 10px;text-align:center}
    header h1{margin:0 0 6px;font-size:22px}
    header p{margin:0;color:var(--muted);font-size:13px}
    .container{max-width:1100px;margin:0 auto;padding:18px;display:grid;gap:16px;grid-template-columns:1.05fr 1fr}
    @media (max-width:980px){.container{grid-template-columns:1fr}}
    .card{background:linear-gradient(180deg,#171a2b,#13162a);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:16px}
    .card h2{margin:0 0 12px;font-size:18px}
    .row{display:grid;gap:12px;grid-template-columns:1fr 1fr}
    @media (max-width:720px){.row{grid-template-columns:1fr}}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input,select,button{width:100%;color:var(--text);background:#101327;border:1px solid #242844;border-radius:10px;padding:12px;font-size:14px;outline:none;transition:border-color .2s,box-shadow .2s}
    input:focus,select:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(108,123,255,.15)}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;background:linear-gradient(180deg,#6c7bff,#5163ff);border:none;border-radius:10px;padding:12px 14px;font-weight:600;cursor:pointer}
    .btn:hover{filter:brightness(1.05)}.btn:active{filter:brightness(.96)}
    .tiny{font-size:11px;color:var(--muted)}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;background:#11142a;border:1px solid #2a2e4b;border-radius:999px;color:var(--muted);font-size:12px}
    .grid{display:grid;gap:10px;grid-template-columns:1fr 1fr}
    @media (max-width:720px){.grid{grid-template-columns:1fr}}
    .stat{background:#0f1327;border:1px dashed #263058;border-radius:10px;padding:12px}
    .stat .k{color:var(--muted);font-size:12px}
    .stat .v{font-weight:700;font-size:16px;margin-top:2px}
    .divider{height:1px;background:#242844;margin:10px 0}
    .flex{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .warn{color:var(--warn)}.good{color:var(--accent2)}
    #debug{white-space:pre-wrap;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;background:#101327;border:1px solid #242844;border-radius:10px;padding:10px;color:#b9c2ff;max-height:180px;overflow:auto}
  </style>
</head>
<body>
  <header>
    <h1>Auto Lot Sizer (1% Risk) – Deriv Live</h1>
    <p>All FX pairs from Deriv • Risk fixed at 1% • Auto price + ATR stop • Only change Balance and Leverage</p>
  </header>

  <div class="container">
    <section class="card">
      <h2>Your Inputs</h2>
      <div class="row">
        <div>
          <label for="balance">Account balance (USD)</label>
          <input id="balance" type="number" step="0.01" placeholder="e.g. 5000" />
        </div>
        <div>
          <label for="leverage">Leverage</label>
          <select id="leverage">
            <option value="1">1:1</option>
            <option value="10">1:10</option>
            <option value="20">1:20</option>
            <option value="30">1:30</option>
            <option value="50">1:50</option>
            <option value="100" selected>1:100</option>
            <option value="200">1:200</option>
            <option value="400">1:400</option>
            <option value="500">1:500</option>
          </select>
        </div>
      </div>

      <div class="divider"></div>

      <h2>Market</h2>
      <div class="row">
        <div>
          <label for="symbol">FX symbol (Deriv)</label>
          <select id="symbol"></select>
        </div>
        <div>
          <label>Live price</label>
          <div class="flex">
            <span id="priceBadge" class="badge">—</span>
            <span id="tickTime" class="tiny">—</span>
            <span id="wsStatus" class="badge">Connecting…</span>
          </div>
        </div>
      </div>
      <p class="tiny">Stop-loss is set automatically to 1× ATR(14) on the H1 timeframe. Risk per trade is fixed at 1% of your balance.</p>

      <div class="divider"></div>
      <div class="tiny">
        Connection diagnostics
        <div id="diag" class="tiny" style="margin:6px 0; color:#ffb020;"></div>
        <div id="debug"></div>
      </div>
    </section>

    <section class="card">
      <h2>Results</h2>
      <div id="alerts" class="tiny warn" style="margin-bottom:10px;"></div>

      <div class="grid" style="margin-bottom:10px;">
        <div class="stat">
          <div class="k">Pip size • Pip value (per 1.00 lot)</div>
          <div class="v" id="pipInfo">—</div>
          <div class="tiny" id="pipInfo2">—</div>
        </div>
        <div class="stat">
          <div class="k">ATR(14) H1 • Stop (pips)</div>
          <div class="v" id="atrInfo">—</div>
          <div class="tiny">Stop = 1 × ATR</div>
        </div>
      </div>

      <div class="grid" style="margin-bottom:10px;">
        <div class="stat">
          <div class="k">Notional per 1.00 lot (USD)</div>
          <div class="v" id="notional">$—</div>
          <div class="tiny">Auto-converted for crosses</div>
        </div>
        <div class="stat">
          <div class="k">Margin per 1.00 lot</div>
          <div class="v" id="marginPerLot">$—</div>
          <div class="tiny">= Notional / Leverage</div>
        </div>
      </div>

      <div class="grid" style="margin-bottom:10px;">
        <div class="stat">
          <div class="k">Recommended lot size</div>
          <div class="v" id="recLot">—</div>
          <div class="tiny">1% risk / (Stop pips × Pip value)</div>
        </div>
        <div class="stat">
          <div class="k">Max positions with this lot</div>
          <div class="v" id="recPosCount">—</div>
          <div class="tiny">Margin-limited only</div>
        </div>
      </div>

      <div class="grid">
        <div class="stat">
          <div class="k">Max total lots by margin</div>
          <div class="v" id="maxLots">—</div>
          <div class="tiny">= Balance / Margin per lot</div>
        </div>
        <div class="stat">
          <div class="k">Per-position margin (rec lot)</div>
          <div class="v" id="perPosMargin">$—</div>
          <div class="tiny">= Rec lot × Margin per lot</div>
        </div>
      </div>
    </section>
  </div>

  <div class="card" style="max-width:1100px;margin:0 auto 22px;">
    <div class="tiny">
      Notes:
      <ul>
        <li>Run from http://localhost (not file://). Many API app_ids block “null” origins.</li>
        <li>If needed, create your own app_id in Deriv → Linked Apps and add your domain to Allowed WebSocket origins.</li>
        <li>1 lot = 100,000 base units (FX). Pip: 0.0001 (non‑JPY), 0.01 (JPY).</li>
      </ul>
    </div>
  </div>

  <script>
    // ===== Deriv WS config with fallbacks =====
    const APP_ID = 1089; // replace with your own for production
    const WS_HOSTS = [
      "wss://ws.deriv.com/websockets/v3",
      "wss://ws.derivws.com/websockets/v3",
      "wss://ws.binaryws.com/websockets/v3"
    ];

    // ===== App constants =====
    const CONTRACT_SIZE_FX = 100000;
    const RISK_PCT = 1;
    const ATR_PERIOD = 14;
    const ATR_GRANULARITY = 3600; // H1

    // ===== State =====
    let ws, connected = false, hostIndex = 0;
    let activeFX = [];
    let currencyToUSD = {};
    let lastMainPrice = null, lastConvPrice = null, lastATR = null;

    // ===== Utils =====
    const $ = id => document.getElementById(id);
    const fmtUSD = (n,d=2)=>isFinite(n)?(n<0?"-$":"$")+Math.abs(n).toLocaleString(undefined,{minimumFractionDigits:d,maximumFractionDigits:d}):"$—";
    const fmtLots = n=>isFinite(n)?Number(n).toFixed(2)+" lots":"—";
    const fmtInt = n=>isFinite(n)?Math.floor(n).toString():"—";
    const nowTime = ts=>new Date(ts).toLocaleTimeString();
    function logDebug(msg){ const el=$("debug"); const line=`${new Date().toLocaleTimeString()}  ${msg}\n`; el.textContent += line; el.scrollTop = el.scrollHeight; }
    function setWsStatus(t){ $("wsStatus").textContent = t; }
    function setDiag(t){ $("diag").textContent = t; }
    function setPriceBadge(p){ $("priceBadge").textContent = isFinite(p)?String(p):"—"; }

    // Helpful origin hint
    (function(){
      if (location.protocol === "file:"){
        setDiag("You are opening this file via file://. Many app_ids reject 'null' origins. Please run from http://localhost (see notes).");
      } else {
        setDiag(`Origin: ${location.origin}`);
      }
    })();

    // ===== Connection w/ fallback =====
    let reqSeq = 1;
    const pending = new Map();
    let keepAliveTimer = null;

    function wsURL(){
      return `${WS_HOSTS[hostIndex]}?app_id=${APP_ID}`;
    }

    function connectWS(){
      try{
        const url = wsURL();
        setWsStatus(`Connecting… (${url})`);
        logDebug(`Connecting to ${url}`);
        ws = new WebSocket(url);
        ws.onopen = () => {
          connected = true;
          setWsStatus("Connected");
          logDebug("Connected");
          // keepalive ping
          clearInterval(keepAliveTimer);
          keepAliveTimer = setInterval(()=>{ try{ ws.send(JSON.stringify({ping:1})); }catch{} }, 25000);
          loadActiveSymbols();
        };
        ws.onclose = (ev) => {
          connected = false;
          clearInterval(keepAliveTimer);
          logDebug(`Closed (code=${ev.code} reason='${ev.reason}')`);
          setWsStatus("Disconnected");
          // Try next host
          hostIndex = (hostIndex + 1) % WS_HOSTS.length;
          setTimeout(connectWS, 900);
        };
        ws.onerror = (e) => {
          logDebug("WebSocket error (check network/adblock/VPN).");
          setWsStatus("Error");
        };
        ws.onmessage = (e) => handleWSMessage(JSON.parse(e.data));
      } catch(err){
        logDebug("Connect error: "+err.message);
        setWsStatus("Error");
      }
    }

    function sendWS(msg, {expectReply=true, timeout=10000}={}){
      return new Promise((resolve, reject) => {
        if (!connected){ reject(new Error("WS not connected")); return; }
        const withId = {...msg, req_id: reqSeq++};
        if (expectReply){
          const timer = setTimeout(() => {
            pending.delete(withId.req_id);
            reject(new Error("Request timeout"));
          }, timeout);
          pending.set(withId.req_id, {resolve, reject, timer});
        }
        ws.send(JSON.stringify(withId));
        if (!expectReply) resolve();
      });
    }

    function handleWSMessage(data){
      if (typeof data.req_id !== "undefined" && pending.has(data.req_id)){
        const p = pending.get(data.req_id);
        clearTimeout(p.timer); pending.delete(data.req_id);
        if (data.error){ p.reject(new Error(data.error.message || "Deriv API error")); }
        else { p.resolve(data); }
        return;
      }
      if (data.error){
        $("alerts").textContent = data.error.message || "Deriv API error";
        logDebug("API error: "+$("alerts").textContent);
      }
      if (data.msg_type === "tick" && data.tick){
        const sym = data.tick.symbol;
        const q = parseFloat(data.tick.quote);
        const t = data.tick.epoch * 1000;
        $("tickTime").textContent = nowTime(t);
        if (sym === $("symbol").value){ lastMainPrice = q; setPriceBadge(q); }
        if (sym === (currencyToUSD.currentConvSymbol || "")){ lastConvPrice = q; }
        calculate();
      }
    }

    // ===== Data loading =====
    async function loadActiveSymbols(){
      try{
        const res = await sendWS({active_symbols:"full", product_type:"basic"});
        const all = res.active_symbols || [];
        const fx = all.filter(s => s.market === "forex" || (s.symbol||"").startsWith("frx"));
        if (!fx.length){
          $("alerts").textContent = "No FX symbols returned. Your region or app_id origin might be restricted.";
          logDebug("active_symbols returned 0 FX symbols.");
          return;
        }
        activeFX = fx.sort((a,b)=> (a.display_name||"").localeCompare(b.display_name||""));
        buildCurrencyConversionMap(activeFX);

        const sel = $("symbol"); sel.innerHTML = "";
        for (const s of activeFX){
          const opt = document.createElement("option");
          opt.value = s.symbol; opt.textContent = s.display_name;
          sel.appendChild(opt);
        }
        const def = (activeFX.find(x=>x.display_name?.includes("EUR/USD")) || activeFX[0])?.symbol;
        if (def) $("symbol").value = def;
        await switchSymbol($("symbol").value);
        setupUIEvents();
        logDebug(`Loaded ${activeFX.length} FX symbols.`);
      } catch(err){
        $("alerts").textContent = "Failed to load symbols: " + err.message;
        logDebug("active_symbols error: "+err.message);
      }
    }

    function parseBaseQuote(display){ const p=(display||"").split("/"); return p.length===2?[p[0].trim().toUpperCase(),p[1].trim().toUpperCase()]:[display?.slice(0,3).toUpperCase(), display?.slice(-3).toUpperCase()]; }

    function buildCurrencyConversionMap(list){
      currencyToUSD = {};
      const hasPair = (b,q)=> list.find(x=>x.display_name === `${b}/${q}`);
      const currencies = new Set();
      for (const s of list){ const [b,q]=parseBaseQuote(s.display_name); currencies.add(b); currencies.add(q); }
      for (const cur of currencies){
        if (cur === "USD") continue;
        const direct = hasPair(cur,"USD");
        if (direct){ currencyToUSD[cur] = {symbol: direct.symbol, method:"multiply"}; continue; }
        const inverse = hasPair("USD",cur);
        if (inverse){ currencyToUSD[cur] = {symbol: inverse.symbol, method:"divide"}; }
      }
    }

    async function switchSymbol(symbol){
      try{
        // stop previous ticks
        await sendWS({forget_all:"ticks"});
      } catch{}
      lastMainPrice = lastConvPrice = lastATR = null;
      currencyToUSD.currentConvSymbol = null;

      await sendWS({ticks: symbol, subscribe:1}, {expectReply:false});

      const meta = activeFX.find(s => s.symbol === symbol);
      const [base, quote] = parseBaseQuote(meta?.display_name || "");

      if (quote !== "USD" && base !== "USD"){
        const conv = currencyToUSD[quote];
        if (conv?.symbol){
          currencyToUSD.currentConvSymbol = conv.symbol;
          await sendWS({ticks: conv.symbol, subscribe:1}, {expectReply:false});
          logDebug(`Cross detected. Converting ${quote}->USD via ${conv.symbol} (${conv.method}).`);
        } else {
          logDebug(`No conversion symbol found for ${quote}→USD.`);
        }
      }
      computeATR(symbol).catch(err => {
        $("alerts").textContent = "ATR error: " + err.message;
        logDebug("ATR error: "+err.message);
      });
    }

    async function computeATR(symbol){
      const resp = await sendWS({
        ticks_history: symbol, style: "candles", granularity: ATR_GRANULARITY, count: 200, end: "latest"
      });
      const candles = resp.candles || [];
      if (candles.length < ATR_PERIOD + 1){ lastATR = NaN; return; }
      let trs = [];
      for (let i=1;i<candles.length;i++){
        const c0 = candles[i-1], c1 = candles[i];
        const prevClose = +c0.close, high = +c1.high, low = +c1.low;
        const tr = Math.max(high-low, Math.abs(high-prevClose), Math.abs(low-prevClose));
        trs.push(tr);
      }
      trs = trs.slice(-ATR_PERIOD);
      lastATR = trs.reduce((a,b)=>a+b,0)/ATR_PERIOD;
      calculate();
    }

    // ===== Calcs =====
    function pipSizeFor(base, quote){ return quote === "JPY" ? 0.01 : 0.0001; }
    function computePipValueUSD(base, quote, price, convPrice){
      const pipSize = pipSizeFor(base, quote);
      if (!isFinite(price) || price <= 0) return {pipSize, pipValUSD: NaN};
      if (quote === "USD") return {pipSize, pipValUSD: CONTRACT_SIZE_FX * pipSize};
      if (base === "USD") return {pipSize, pipValUSD: (CONTRACT_SIZE_FX * pipSize) / price};
      const pipValueQuote = CONTRACT_SIZE_FX * pipSize;
      if (!isFinite(convPrice) || convPrice <= 0) return {pipSize, pipValUSD: NaN};
      return {pipSize, pipValUSD: currencyToUSD[quote]?.method === "multiply" ? pipValueQuote * convPrice : pipValueQuote / convPrice};
    }
    function computeNotionalUSD(base, quote, price, convPrice){
      if (!isFinite(price) || price <= 0) return NaN;
      if (base === "USD") return CONTRACT_SIZE_FX;
      if (quote === "USD") return CONTRACT_SIZE_FX * price;
      if (!isFinite(convPrice) || convPrice <= 0) return NaN;
      return currencyToUSD[quote]?.method === "multiply" ? CONTRACT_SIZE_FX * price * convPrice : CONTRACT_SIZE_FX * price / convPrice;
    }
    function getSelectedBaseQuote(){
      const meta = activeFX.find(s => s.symbol === $("symbol").value);
      return parseBaseQuote(meta?.display_name || "");
    }

    function calculate(){
      const alerts = [];
      const balance = parseFloat($("balance").value);
      const leverage = parseFloat($("leverage").value);
      if (!isFinite(balance) || balance <= 0) alerts.push("Enter a positive balance.");
      if (!isFinite(leverage) || leverage <= 0) alerts.push("Select a valid leverage.");

      const [base, quote] = getSelectedBaseQuote();
      const price = lastMainPrice;
      const convPrice = (quote !== "USD" && base !== "USD") ? lastConvPrice : null;

      const {pipSize, pipValUSD} = computePipValueUSD(base, quote, price, convPrice);
      const notionalUSD = computeNotionalUSD(base, quote, price, convPrice);
      const marginPerLot = isFinite(notionalUSD) && leverage > 0 ? notionalUSD / leverage : NaN;
      const maxLots = isFinite(balance) && marginPerLot > 0 ? balance / marginPerLot : NaN;

      let stopPips = NaN;
      if (isFinite(lastATR) && isFinite(pipSize) && pipSize > 0) stopPips = lastATR / pipSize;
      else alerts.push("Waiting for ATR(14) H1…");

      let recLot = NaN, perPosMargin = NaN, recPosCount = NaN;
      if (isFinite(balance) && isFinite(stopPips) && stopPips > 0 && isFinite(pipValUSD) && pipValUSD > 0){
        const riskAmt = balance * (RISK_PCT/100);
        recLot = Math.max(0, Math.floor((riskAmt / (stopPips * pipValUSD)) * 100) / 100); // 0.01 rounding
        if (recLot > 0 && isFinite(marginPerLot)){
          perPosMargin = recLot * marginPerLot;
          recPosCount = Math.floor(balance / perPosMargin);
        }
      }

      $("alerts").textContent = alerts.join(" ");
      $("pipInfo").textContent = isFinite(pipSize) && isFinite(pipValUSD) ? `${pipSize} • ${fmtUSD(pipValUSD)} / pip` : "—";
      $("pipInfo2").textContent = (quote !== "USD" && base !== "USD") ? `Converted via ${currencyToUSD[quote]?.symbol || "—"}` : "—";
      $("atrInfo").textContent = isFinite(lastATR) && isFinite(stopPips) ? `${lastATR.toFixed(5)} • ${stopPips.toFixed(1)} pips` : "—";
      $("notional").textContent = fmtUSD(notionalUSD);
      $("marginPerLot").textContent = fmtUSD(marginPerLot);
      $("maxLots").textContent = isFinite(maxLots) ? fmtLots(maxLots) : "—";
      $("recLot").textContent = isFinite(recLot) && recLot > 0 ? fmtLots(recLot) : "—";
      $("perPosMargin").textContent = isFinite(perPosMargin) ? fmtUSD(perPosMargin) : "—";
      $("recPosCount").textContent = isFinite(recPosCount) ? fmtInt(recPosCount) : "—";
    }

    function setupUIEvents(){
      $("symbol").addEventListener("change", async () => {
        setPriceBadge("—"); $("tickTime").textContent = "—";
        await switchSymbol($("symbol").value);
      });
      ["balance","leverage"].forEach(id => {
        $(id).addEventListener("input", calculate);
        $(id).addEventListener("change", calculate);
      });
    }

    // Boot
    connectWS();
  </script>
</body>
</html>
