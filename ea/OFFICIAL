//+------------------------------------------------------------------+
//|                                    MA3_5_Donchian_9MA_TP.mq5     |
//|  3 & 5 MA crossover, SL at Donchian outer band, TP near 9 MA     |
//|  Added: MACD crossover confirmation                              |
//+------------------------------------------------------------------+
#property strict
#property copyright "You"
#property version   "1.03"
#property description "MT5 EA: 3&5 MA crossover, Donchian SL, TP near 9 MA with MACD confirmation"

#include <Trade/Trade.mqh>

//--- inputs
input int               FastMAPeriod       = 3;         // Fast MA period
input int               SlowMAPeriod       = 7;         // Slow MA period
input int               TargetMAPeriod     = 24;         // Target MA period (for TP)
input ENUM_MA_METHOD    MAMethod           = MODE_EMA;  // MA method
input ENUM_APPLIED_PRICE MAPrice           = PRICE_CLOSE; // Applied price for MAs

input int               DonchianPeriod     = 20;        // Donchian Channel lookback bars

// TP settings:
// distance from the 9 MA in *price units* (NOT points):
// e.g. 0.5 on something like 209.0, 209.5, 210.0
// e.g. 0.0010 on EURUSD (10 pips if digits=5)
input double            TpOffsetPrice      = 0.5;

input double            Lots               = 1.17;      // Requested lot size (min 1.11, adjusted to broker limits)
input int               SlippagePoints     = 10;        // Max slippage in points
input ulong             MagicNumber        = 3005001;   // Magic number for this EA
input bool              OnlyOnePosition    = true;      // Allow only one position per symbol for this EA
input bool              CloseOnOppSignal   = true;      // Close existing position when opposite crossover appears

// --- MACD filter settings
input bool              UseMACDFilter      = true;      // Require MACD confirmation for entries
input int               MACDFastPeriod     = 12;        // MACD fast EMA period
input int               MACDSlowPeriod     = 26;        // MACD slow EMA period
input int               MACDSignalPeriod   = 9;         // MACD signal SMA period
input ENUM_APPLIED_PRICE MACDPrice         = PRICE_CLOSE; // Applied price for MACD
input int               MACDConfirmBars    = 15;         // Look-back bars for MACD cross confirmation

//--- trade object
CTrade trade;

//--- indicator handles
int fastMA_handle   = INVALID_HANDLE;
int slowMA_handle   = INVALID_HANDLE;
int targetMA_handle = INVALID_HANDLE;
int macd_handle     = INVALID_HANDLE;      // MACD handle

//--- for "once per bar" logic
datetime last_bar_time = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber((int)MagicNumber);
   trade.SetDeviationInPoints(SlippagePoints);

   // Create MA handles
   fastMA_handle = iMA(_Symbol, _Period, FastMAPeriod, 0, MAMethod, MAPrice);
   if(fastMA_handle == INVALID_HANDLE)
   {
      Print("Error creating fast MA handle: ", GetLastError());
      return(INIT_FAILED);
   }

   slowMA_handle = iMA(_Symbol, _Period, SlowMAPeriod, 0, MAMethod, MAPrice);
   if(slowMA_handle == INVALID_HANDLE)
   {
      Print("Error creating slow MA handle: ", GetLastError());
      return(INIT_FAILED);
   }

   targetMA_handle = iMA(_Symbol, _Period, TargetMAPeriod, 0, MAMethod, MAPrice);
   if(targetMA_handle == INVALID_HANDLE)
   {
      Print("Error creating target MA handle: ", GetLastError());
      return(INIT_FAILED);
   }

   // Create MACD handle (only if the filter is used)
   if(UseMACDFilter)
   {
      macd_handle = iMACD(_Symbol,
                          _Period,
                          MACDFastPeriod,
                          MACDSlowPeriod,
                          MACDSignalPeriod,
                          MACDPrice);
      if(macd_handle == INVALID_HANDLE)
      {
         Print("Error creating MACD handle: ", GetLastError());
         return(INIT_FAILED);
      }
   }

   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   if(fastMA_handle   != INVALID_HANDLE) IndicatorRelease(fastMA_handle);
   if(slowMA_handle   != INVALID_HANDLE) IndicatorRelease(slowMA_handle);
   if(targetMA_handle != INVALID_HANDLE) IndicatorRelease(targetMA_handle);
   if(macd_handle     != INVALID_HANDLE) IndicatorRelease(macd_handle);
}

//+------------------------------------------------------------------+
//| Get current number of EA positions (this symbol & magic)         |
//+------------------------------------------------------------------+
int CountOurPositions(int &buyCount, int &sellCount)
{
   buyCount  = 0;
   sellCount = 0;
   int total = PositionsTotal();

   for(int i = 0; i < total; i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket))
         continue;

      string sym    = PositionGetString(POSITION_SYMBOL);
      long   magic  = PositionGetInteger(POSITION_MAGIC);
      long   type   = PositionGetInteger(POSITION_TYPE);

      if(sym == _Symbol && magic == (long)MagicNumber)
      {
         if(type == POSITION_TYPE_BUY)
            buyCount++;
         else if(type == POSITION_TYPE_SELL)
            sellCount++;
      }
   }
   return (buyCount + sellCount);
}

//+------------------------------------------------------------------+
//| Normalize volume to broker constraints                           |
//+------------------------------------------------------------------+
double NormalizedVolume(double vol)
{
   double minLot, maxLot, lotStep;
   SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN,  minLot);
   SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX,  maxLot);
   SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP, lotStep);

   // Force at least requested 1.11, then clamp to broker bounds
   if(vol < 1.11) vol = 1.11;

   if(vol < minLot) vol = minLot;
   if(vol > maxLot) vol = maxLot;

   // Adjust to the nearest lower multiple of lotStep
   vol = MathFloor(vol / lotStep) * lotStep;
   vol = NormalizeDouble(vol, 2); // adjust decimals if your symbol requires more
   return vol;
}

//+------------------------------------------------------------------+
//| Calculate Donchian Channel                                       |
//+------------------------------------------------------------------+
bool GetDonchian(double &upper, double &lower)
{
   int bars = Bars(_Symbol, _Period);
   if(bars <= DonchianPeriod + 2)
      return false;

   // Use completed bars only: from shift=1 to DonchianPeriod
   int highestIndex = iHighest(_Symbol, _Period, MODE_HIGH, DonchianPeriod, 1);
   int lowestIndex  = iLowest(_Symbol, _Period, MODE_LOW,  DonchianPeriod, 1);

   if(highestIndex == -1 || lowestIndex == -1)
      return false;

   upper = iHigh(_Symbol, _Period, highestIndex);
   lower = iLow(_Symbol,  _Period, lowestIndex);

   return true;
}

//+------------------------------------------------------------------+
//| Check for MA crossover signals (uses CopyBuffer on MA handles)   |
//+------------------------------------------------------------------+
void GetMASignals(bool &buySignal, bool &sellSignal)
{
   buySignal  = false;
   sellSignal = false;

   // Need enough bars
   if(Bars(_Symbol, _Period) < MathMax(FastMAPeriod, SlowMAPeriod) + 3)
      return;

   double fastVals[2];
   double slowVals[2];

   // fast MA: from shift=1 (closed bar), count=2 => [0]=shift1, [1]=shift2
   if(CopyBuffer(fastMA_handle, 0, 1, 2, fastVals) != 2)
      return;

   // slow MA
   if(CopyBuffer(slowMA_handle, 0, 1, 2, slowVals) != 2)
      return;

   double maFastCurr = fastVals[0]; // shift 1 (last closed bar)
   double maFastPrev = fastVals[1]; // shift 2
   double maSlowCurr = slowVals[0];
   double maSlowPrev = slowVals[1];

   // Bullish crossover: fast crosses above slow
   if(maFastPrev <= maSlowPrev && maFastCurr > maSlowCurr)
      buySignal = true;

   // Bearish crossover: fast crosses below slow
   if(maFastPrev >= maSlowPrev && maFastCurr < maSlowCurr)
      sellSignal = true;
}

//+------------------------------------------------------------------+
//| Get TP price: area near 9 MA (offset from MA)                    |
//+------------------------------------------------------------------+
bool GetTargetPrice(bool isBuy, double &tp_price)
{
   tp_price = 0.0;

   double maArr[1];

   // 9 MA on last closed bar (shift = 1)
   if(CopyBuffer(targetMA_handle, 0, 1, 1, maArr) != 1)
      return false;

   double maTarget = maArr[0];
   if(maTarget <= 0.0)
      return false;

   // For BUY: TP just below the 9 MA
   // For SELL: TP just above the 9 MA
   if(isBuy)
      tp_price = maTarget - TpOffsetPrice;
   else
      tp_price = maTarget + TpOffsetPrice;

   tp_price = NormalizeDouble(tp_price, _Digits);
   return true;
}

//+------------------------------------------------------------------+
//| Check MACD main/signal cross within last N closed bars           |
//+------------------------------------------------------------------+
bool GetMACDCrossSignals(bool &bullishCross, bool &bearishCross)
{
   bullishCross = false;
   bearishCross = false;

   if(!UseMACDFilter)
      return true;        // Filter not used -> everything passes

   if(macd_handle == INVALID_HANDLE)
      return false;

   int bars = Bars(_Symbol, _Period);
   // Basic safety check for enough bars
   if(bars <= MACDSlowPeriod + MACDSignalPeriod + MACDConfirmBars + 2)
      return false;

   int need_bars = MACDConfirmBars + 1; // to check MACDConfirmBars possible crosses
   double macdMain[];
   double macdSignal[];

   // MACD main and signal on closed bars starting from shift=1
   if(CopyBuffer(macd_handle, 0, 1, need_bars, macdMain) != need_bars)
      return false;
   if(CopyBuffer(macd_handle, 1, 1, need_bars, macdSignal) != need_bars)
      return false;

   // Scan from most recent closed bar to older ones
   for(int i = 0; i < MACDConfirmBars; i++)
   {
      int curr = i;       // shift = i+1
      int prev = i + 1;   // shift = i+2

      double mainPrev = macdMain[prev];
      double sigPrev  = macdSignal[prev];
      double mainCurr = macdMain[curr];
      double sigCurr  = macdSignal[curr];

      // Bullish MACD crossover: main crosses above signal
      if(mainPrev <= sigPrev && mainCurr > sigCurr)
      {
         bullishCross = true;
         break;
      }

      // Bearish MACD crossover: main crosses below signal
      if(mainPrev >= sigPrev && mainCurr < sigCurr)
      {
         bearishCross = true;
         break;
      }
   }

   // true = we successfully read data (even if no cross was found)
   return true;
}

//+------------------------------------------------------------------+
//| Manage existing positions: optional close on opposite signal     |
//+------------------------------------------------------------------+
void ManageOpenPositions(bool buySignal, bool sellSignal)
{
   if(!CloseOnOppSignal)
      return;

   int total = PositionsTotal();
   for(int i = total - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket))
         continue;

      string sym    = PositionGetString(POSITION_SYMBOL);
      long   magic  = PositionGetInteger(POSITION_MAGIC);
      long   type   = PositionGetInteger(POSITION_TYPE);

      if(sym != _Symbol || magic != (long)MagicNumber)
         continue;

      // If we have a buy and now a sell signal -> close buy
      if(type == POSITION_TYPE_BUY && sellSignal)
      {
         trade.PositionClose(ticket);
      }
      // If we have a sell and now a buy signal -> close sell
      if(type == POSITION_TYPE_SELL && buySignal)
      {
         trade.PositionClose(ticket);
      }
   }
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Run only once per new bar
   datetime current_bar_time = iTime(_Symbol, _Period, 0);
   if(current_bar_time == last_bar_time)
      return;
   last_bar_time = current_bar_time;

   // Get latest tick
   MqlTick tick;
   if(!SymbolInfoTick(_Symbol, tick))
      return;

   // Count our positions
   int buyCount, sellCount;
   int ourPositions = CountOurPositions(buyCount, sellCount);

   // Get MA crossover signals (base signals)
   bool buySignalMA, sellSignalMA;
   GetMASignals(buySignalMA, sellSignalMA);

   // Manage open positions (close on opposite MA crossover)
   if(ourPositions > 0)
      ManageOpenPositions(buySignalMA, sellSignalMA);

   // Re-count after possible closes
   ourPositions = CountOurPositions(buyCount, sellCount);

   // If only one position allowed, skip if one is open
   if(OnlyOnePosition && ourPositions > 0)
      return;

   // Start with MA signals for potential new entries
   bool buySignal  = buySignalMA;
   bool sellSignal = sellSignalMA;

   // --- MACD confirmation filter for entries ---
   if(UseMACDFilter && (buySignal || sellSignal))
   {
      bool macdBull = false;
      bool macdBear = false;

      if(!GetMACDCrossSignals(macdBull, macdBear))
      {
         // Could not read MACD properly -> block new entries this bar
         buySignal  = false;
         sellSignal = false;
      }
      else
      {
         // Require MACD cross of same direction sometime in last MACDConfirmBars
         if(buySignal && !macdBull)
            buySignal = false;
         if(sellSignal && !macdBear)
            sellSignal = false;
      }
   }

   // No new entry signal after MACD filter
   if(!buySignal && !sellSignal)
      return;

   // Calculate Donchian channel for SL
   double donUpper, donLower;
   if(!GetDonchian(donUpper, donLower))
      return;

   // Get minimal stop distance (if broker enforces any)
   long stopsLevel = 0;
   SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL, stopsLevel);
   double minStop = stopsLevel * _Point;

   // Normalize volume
   double volume = NormalizedVolume(Lots);
   if(volume <= 0.0)
      return;

   double sl = 0.0, tp = 0.0;

   // BUY entry
   if(buySignal && (!OnlyOnePosition || buyCount == 0))
   {
      // SL at lower Donchian band
      if(donLower > 0 && (tick.ask - donLower) >= minStop)
         sl = NormalizeDouble(donLower, _Digits);
      else
         sl = 0.0; // if too close, no SL

      // TP near 9 MA (below it by offset)
      if(!GetTargetPrice(true, tp))
         tp = 0.0; // no TP if MA read failed

      // Send buy order at market
      trade.Buy(volume, _Symbol, 0.0, sl, tp, "VINCEVISIONMA3_5_Donchian_9MA_TP + MACD buy");
   }

   // SELL entry
   if(sellSignal && (!OnlyOnePosition || sellCount == 0))
   {
      // SL at upper Donchian band
      if(donUpper > 0 && (donUpper - tick.bid) >= minStop)
         sl = NormalizeDouble(donUpper, _Digits);
      else
         sl = 0.0;

      // TP near 9 MA (above it by offset)
      if(!GetTargetPrice(false, tp))
         tp = 0.0;

      // Send sell order at market
      trade.Sell(volume, _Symbol, 0.0, sl, tp, "VINCEVISIONMA3_5_Donchian_9MA_TP + MACD sell");
   }
}
//+------------------------------------------------------------------+
